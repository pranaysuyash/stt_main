Directory Structure:
```
├── public/
├── src/
│   ├── assets/
│   │   ├── fonts/
│   │   ├── icons/
│   │   └── images/
│   ├── components/
│   │   ├── common/
│   │   │   ├── AudioPlayer.jsx
│   │   │   ├── Breadcrumbs.jsx
│   │   │   ├── Button.jsx
│   │   │   ├── ErrorBoundary.jsx
│   │   │   ├── FileDashboard.jsx
│   │   │   ├── FileUploader.jsx
│   │   │   ├── Layout.jsx
│   │   │   ├── Loader.jsx
│   │   │   ├── MediaPlayer.jsx
│   │   │   ├── Messages.jsx
│   │   │   ├── Notification.jsx
│   │   │   ├── PreviewSection.jsx
│   │   │   ├── ProgressBar.jsx
│   │   │   ├── QuickAccessToolbar.jsx
│   │   │   ├── SideNav.jsx
│   │   │   ├── Tooltip.jsx
│   │   │   ├── VideoPlayer.jsx
│   │   │   └── WaveformViewer.jsx
│   │   └── pages/
│   │       ├── Dashboard.jsx
│   │       ├── Help.jsx
│   │       ├── Library.jsx
│   │       ├── Settings.jsx
│   │       └── Upload.jsx
│   ├── styles/
│   │   ├── GlobalStyle.js
│   │   └── theme.js
│   ├── App.jsx
│   └── main.jsx
├── static/
│   ├── css/
│   ├── js/
│   └── uploads/
├── templates/
├── app.py
├── audio_processing.py
├── eslint.config.js
├── index.html
├── test.jsx
├── test.py
└── vite.config.js
```

## File: test.jsx

```jsx
// src/App.jsx
import React from 'react';
import styled, { ThemeProvider } from 'styled-components';
import GlobalStyle from './styles/GlobalStyle';
import { theme } from './styles/theme';
import ErrorBoundary from './components/common/ErrorBoundary';
import Layout from './components/common/Layout';
import { Switch, Route, Redirect } from 'react-router-dom';
import Dashboard from './components/pages/Dashboard';
import Upload from './components/pages/Upload';
import Settings from './components/pages/Settings';
import Help from './components/pages/Help'; // You'll need to create a Help page
import Library from './components/pages/Library'; // You'll need to create a Library page
const AppContainer = styled.div`
  /* Additional global styles if needed */
`;
function App() {
  return (
    <ThemeProvider theme={theme}>
      <GlobalStyle />
      <ErrorBoundary>
        <AppContainer>
          <Layout>
            <Switch>
              <Route exact path="/">
                <Redirect to="/dashboard" />
              </Route>
              <Route path="/dashboard" component={Dashboard} />
              <Route path="/upload" component={Upload} />
              <Route path="/library" component={Library} />
              <Route path="/analysis" component={() => <div>Analysis Page (To Be Implemented)</div>} />
              <Route path="/settings" component={Settings} />
              <Route path="/help" component={() => <div>Help Page (To Be Implemented)</div>} />
              <Route path="*">
                <div>404 - Page Not Found</div>
              </Route>
            </Switch>
          </Layout>
        </AppContainer>
      </ErrorBoundary>
    </ThemeProvider>
  );
}
export default App;
```

## File: index.html

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Audio/Video Waveform Analyzer</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;600&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/main.jsx"></script>
  </body>
</html>
```

## File: audio_processing.py

```py
from moviepy.editor import VideoFileClip
import matplotlib.pyplot as plt
from pydub import AudioSegment
import numpy as np
plt.switch_backend('Agg')
# Function to extract audio from a video file
def extract_audio_from_video(video_path, output_audio_path):
    """
    Extracts the audio track from a video file and saves it as a separate audio file.
    Args:
    - video_path: Path to the video file.
    - output_audio_path: Path where the extracted audio file will be saved.
    Returns:
    - Path to the extracted audio file or None if the video has no audio.
    """
    video = VideoFileClip(video_path)
    # Check if the video has an audio track
    if video.audio is None:
        print("No audio track found in the video.")
        return None
    # If audio is present, write it to the specified file
    audio = video.audio
    audio.write_audiofile(output_audio_path)
    return output_audio_path
# Function to generate a waveform image from an audio file
def generate_waveform(audio_file, output_image_path):
    """
    Generates a waveform image from an audio file and saves it as an image.
    Args:
    - audio_file: Path to the audio file.
    - output_image_path: Path where the waveform image will be saved.
    Returns:
    - Path to the generated waveform image.
    """
    # Load the audio file using pydub
    audio = AudioSegment.from_file(audio_file)
    # Get the raw audio data as a numpy array
    data = np.array(audio.get_array_of_samples())
    # Create the waveform plot using matplotlib
    plt.figure(figsize=(10, 4))
    plt.plot(data, color='blue')
    plt.fill_between(range(len(data)), data, color='skyblue', alpha=0.4)
    plt.title('Waveform')
    plt.xlabel('Time (samples)')
    plt.ylabel('Amplitude')
    # Save the generated waveform image
    plt.savefig(output_image_path)
    plt.close()
    return output_image_path
```

## File: vite.config.js

```js
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'), // Optional: Alias for easier imports
    },
  },
  server: {
    port: 5173, // Explicitly set the port
    host: true, // Allows access from other devices on your network
    strictPort: false, // Allows Vite to increment the port if 5173 is already in use
    proxy: {
      '/upload': 'http://localhost:5555', 
      '/api': 'http://localhost:5555', // Proxy API calls to Flask backend
      '/static': {
        target: 'http://localhost:5555',   // Proxy static file requests (uploads, etc.)
        changeOrigin: true,
      },
    },
    open: true, // Automatically open the app in the browser when the server starts
  },
  base: './', // Ensures correct asset path resolution
});
```

## File: test.py

```py
from flask import Flask, render_template, request, jsonify, send_file
import os
import logging
from werkzeug.utils import secure_filename
from audio_processing import extract_audio_from_video, generate_waveform
from flask_cors import CORS
import mimetypes
# Initialize Flask app
app = Flask(__name__)
CORS(app, resources={r"/static/uploads/*": {"origins": "*"}})
logging.basicConfig(level=logging.DEBUG)
# Ensure uploads directory exists
UPLOAD_FOLDER = 'static/uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 250 * 1024 * 1024  # 250MB max file size
ALLOWED_EXTENSIONS = {'mp3', 'wav', 'mp4', 'avi', 'mov', 'mkv'}
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
# Single Error handler for large files
@app.errorhandler(413)
def request_entity_too_large(error):
    app.logger.error('File too large')
    return jsonify({
        'error': 'File too large',
        'max_size': '250MB',
        'message': 'Please try compressing your file or splitting it into smaller parts before uploading.'
    }), 413
@app.route('/')
def index():
    return render_template('index.html')
# Handle file uploads (audio/video)
@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        app.logger.error('No file part in request.')
        return jsonify({'error': 'No file part in the request.'}), 400
    files = request.files.getlist('file')
    if not files or len(files) == 0:
        app.logger.error('No files selected for upload.')
        return jsonify({'error': 'No files selected for upload.'}), 400
    allowed_mimetypes = {
        'audio/mpeg',
        'audio/wav',
        'video/mp4',
        'video/x-msvideo',
        'video/quicktime'  # Added to allow .mov files
    }
    uploaded_files = []
    errors = []
    for file in files:
        if file.filename == '':
            app.logger.warning('Empty filename encountered, skipping file.')
            errors.append({'filename': '', 'error': 'Empty filename.'})
            continue  # Skip files with no filename
        if not allowed_file(file.filename):
            app.logger.warning(f'Unsupported file extension: {file.filename}')
            errors.append({'filename': file.filename, 'error': 'Unsupported file extension.'})
            continue
        if file.mimetype not in allowed_mimetypes:
            app.logger.warning(f'Unsupported MIME type: {file.filename} with type {file.mimetype}')
            errors.append({'filename': file.filename, 'error': 'Unsupported MIME type.'})
            continue
        if file.content_length > app.config['MAX_CONTENT_LENGTH']:
            app.logger.warning(f'File too large: {file.filename}')
            errors.append({'filename': file.filename, 'error': 'File size exceeds the 250MB limit.'})
            continue
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        try:
            file.save(file_path)
            app.logger.info(f'File saved: {file_path}')
            file_info = {
                'filename': filename,
                'path': f'/static/uploads/{filename}',
                'size': os.path.getsize(file_path),
                'type': file.mimetype
            }
            uploaded_files.append(file_info)
        except Exception as e:
            app.logger.error(f'Error processing file {filename}: {e}')
            errors.append({'filename': filename, 'error': 'Failed to process the file.'})
    response = {}
    if uploaded_files:
        response['uploaded_files'] = uploaded_files
    if errors:
        response['errors'] = errors
    status_code = 200 if uploaded_files and not errors else 207  # 207 Multi-Status if partial success
    return jsonify(response), status_code
# Endpoint to fetch waveform for previously uploaded files (optional)
@app.route('/waveform/<filename>', methods=['GET'])
def get_waveform(filename):
    audio_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    waveform_image = os.path.join(app.config['UPLOAD_FOLDER'], 'waveform.png')
    # Check if the file is a video
    if filename.endswith('.mp4') or filename.endswith('.avi') or filename.endswith('.mov') or filename.endswith('.mkv'):
        extract_audio_from_video(audio_path, os.path.join(app.config['UPLOAD_FOLDER'], 'extracted_audio.wav'))
    # Generate waveform for audio
    generate_waveform(os.path.join(app.config['UPLOAD_FOLDER'], 'extracted_audio.wav'), waveform_image)
    # Return the waveform image
    return send_file(waveform_image, mimetype='image/png')
@app.route('/api/file_exists', methods=['GET'])
def file_exists():
    filename = request.args.get('filename')
    if not filename:
        return jsonify({'error': 'No filename provided'}), 400
    file_path = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(filename))
    if os.path.isfile(file_path):
        return jsonify({'exists': True})
    return jsonify({'exists': False})
# List upload history
@app.route('/api/file_history', methods=['GET'])
def file_history():
    files = os.listdir(app.config['UPLOAD_FOLDER'])
    file_list = []
    for f in files:
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], f)
        if os.path.isfile(file_path):
            mime_type, _ = mimetypes.guess_type(file_path)
            file_info = {
                'filename': f,
                'path': f'/static/uploads/{f}',
                'size': os.path.getsize(file_path),
                'type': mime_type or 'application/octet-stream',
            }
            file_list.append(file_info)
    return jsonify({'files': file_list})
# Main function to run the Flask app
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5555, debug=True)
```

## File: app.py

```py
from flask import Flask, render_template, request, jsonify, send_file
import os
import logging
from werkzeug.utils import secure_filename
from audio_processing import extract_audio_from_video, generate_waveform
from flask_cors import CORS
from moviepy.editor import VideoFileClip
from mutagen import File as MutagenFile  # Ensure mutagen is installed
import mimetypes
# Initialize Flask app
app = Flask(__name__)
CORS(app, resources={r"/static/uploads/*": {"origins": "*"}})
logging.basicConfig(level=logging.DEBUG)
# Ensure uploads directory exists
UPLOAD_FOLDER = 'static/uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 250 * 1024 * 1024  # 200MB max file size
ALLOWED_EXTENSIONS = {'mp3', 'wav', 'mp4', 'avi', 'mov', 'mkv'}
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS
# Error handler for large files
@app.errorhandler(413)
def request_entity_too_large(error):
    app.logger.error('File too large')
    return jsonify({
        'error': 'File too large',
        'max_size': '250MB',
        'message': 'Please try compressing your file or splitting it into smaller parts before uploading.'
    }), 413
@app.route('/')
def index():
    return render_template('index.html')
# Handle file uploads (audio/video)
# @app.route('/upload', methods=['POST'])
# def upload_file():
#     if 'file' not in request.files:
#         return jsonify({'error': 'No file part'}), 400
#     file = request.files['file']
#     if file.filename == '':
#         return jsonify({'error': 'No selected file'}), 400
#     if file:
#         filename = secure_filename(file.filename)
#         file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
#         try:
#             file.save(file_path)
#             # Check if it's a video file and try extracting the audio
#             if file.mimetype.startswith('video'):
#                 audio_path = os.path.join(app.config['UPLOAD_FOLDER'], 'extracted_audio.wav')
#                 extracted_audio = extract_audio_from_video(file_path, audio_path)
#                 # If the video has no audio, return a warning message
#                 if extracted_audio is None:
#                     return jsonify({'filename': filename, 'path': f'/static/uploads/{filename}', 'warning': 'No audio track found'})
#                 # Generate waveform from extracted audio
#                 waveform_image = os.path.join(app.config['UPLOAD_FOLDER'], 'waveform.png')
#                 generate_waveform(extracted_audio, waveform_image)
#             return jsonify({'filename': filename, 'path': f'/static/uploads/{filename}'})
#         except Exception as e:
#             return jsonify({'error': 'Failed to save file', 'message': str(e)}), 500
@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        app.logger.error('No file part in request.')
        return jsonify({'error': 'No file part in the request.'}), 400
    files = request.files.getlist('file')
    if not files or len(files) == 0:
        app.logger.error('No files selected for upload.')
        return jsonify({'error': 'No files selected for upload.'}), 400
    allowed_mimetypes = {
        'audio/mpeg',
        'audio/wav',
        'video/mp4',
        'video/x-msvideo',
        'video/quicktime'  # Added to allow .mov files
    }
    uploaded_files = []
    errors = []
    for file in files:
        if file.filename == '':
            app.logger.warning('Empty filename encountered, skipping file.')
            errors.append({'filename': '', 'error': 'Empty filename.'})
            continue  # Skip files with no filename
        if not allowed_file(file.filename):
            app.logger.warning(f'Unsupported file extension: {file.filename}')
            errors.append({'filename': file.filename, 'error': 'Unsupported file extension.'})
            continue
        if file.mimetype not in allowed_mimetypes:
            app.logger.warning(f'Unsupported MIME type: {file.filename} with type {file.mimetype}')
            errors.append({'filename': file.filename, 'error': 'Unsupported MIME type.'})
            continue
        if file.content_length > app.config['MAX_CONTENT_LENGTH']:
            app.logger.warning(f'File too large: {file.filename}')
            errors.append({'filename': file.filename, 'error': 'File size exceeds the 200MB limit.'})
            continue
        filename = secure_filename(file.filename)
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        try:
            file.save(file_path)
            app.logger.info(f'File saved: {file_path}')
            file_info = {
                'filename': filename,
                'path': f'/static/uploads/{filename}',
                'size': os.path.getsize(file_path),
                'type': file.mimetype
            }
            uploaded_files.append(file_info)
        except Exception as e:
            app.logger.error(f'Error processing file {filename}: {e}')
            errors.append({'filename': filename, 'error': 'Failed to process the file.'})
    response = {}
    if uploaded_files:
        response['uploaded_files'] = uploaded_files
    if errors:
        response['errors'] = errors
    status_code = 200 if uploaded_files and not errors else 207  # 207 Multi-Status if partial success
    return jsonify(response), status_code
# Endpoint to fetch waveform for previously uploaded files (optional)
@app.route('/waveform/<filename>', methods=['GET'])
def get_waveform(filename):
    audio_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
    waveform_image = os.path.join(app.config['UPLOAD_FOLDER'], 'waveform.png')
    # Check if the file is a video
    if filename.endswith('.mp4') or filename.endswith('.avi'):
        extract_audio_from_video(audio_path, os.path.join(app.config['UPLOAD_FOLDER'], 'extracted_audio.wav'))
    # Generate waveform for audio
    generate_waveform(os.path.join(app.config['UPLOAD_FOLDER'], 'extracted_audio.wav'), waveform_image)
    # Return the waveform image
    return send_file(waveform_image, mimetype='image/png')
@app.route('/api/file_exists', methods=['GET'])
def file_exists():
    filename = request.args.get('filename')
    if not filename:
        return jsonify({'error': 'No filename provided'}), 400
    file_path = os.path.join(app.config['UPLOAD_FOLDER'], secure_filename(filename))
    if os.path.isfile(file_path):
        return jsonify({'exists': True})
    return jsonify({'exists': False})
# List upload history
# Ensure that your `/api/file_history` endpoint properly returns the full list of files.
# @app.route('/api/file_history', methods=['GET'])
# def file_history():
#     files = os.listdir(app.config['UPLOAD_FOLDER'])
#     file_list = [{'filename': f, 'path': f'/static/uploads/{f}'} for f in files if os.path.isfile(os.path.join(app.config['UPLOAD_FOLDER'], f))]
#     return jsonify({'files': file_list})  # Return the list of files correctly
@app.route('/api/file_history', methods=['GET'])
def file_history():
    files = os.listdir(app.config['UPLOAD_FOLDER'])
    file_list = []
    for f in files:
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], f)
        if os.path.isfile(file_path):
            mime_type, _ = mimetypes.guess_type(file_path)
            file_info = {
                'filename': f,
                'path': f'/static/uploads/{f}',
                'size': os.path.getsize(file_path),
                'type': mime_type or 'application/octet-stream',
            }
            file_list.append(file_info)
    return jsonify({'files': file_list})
# # Error handler for large files
# @app.errorhandler(413)
# def request_entity_too_large(error):
#     app.logger.error('File too large')
#     return jsonify({
#         'error': 'File too large',
#         'max_size': '200MB',
#         'message': 'Please try compressing your file or splitting it into smaller parts before uploading.'
#     }), 413
# Main function to run the Flask app
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5555, debug=True)
```

## File: eslint.config.js

```js
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]
```

## File: src/main.jsx

```jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";
import "@fortawesome/fontawesome-free/css/all.min.css"; // Ensure FontAwesome is installed
import { BrowserRouter as Router } from "react-router-dom";
createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <Router>
      <App />
    </Router>
  </React.StrictMode>
);
```

## File: src/App.jsx

```jsx
// src/App.jsx
import React , { Suspense, lazy } from 'react';
import styled, { ThemeProvider } from 'styled-components';
import GlobalStyle from './styles/GlobalStyle';
import { theme } from './styles/theme';
import ErrorBoundary from './components/common/ErrorBoundary';
import Layout from './components/common/Layout';
import { Routes, Route, Navigate } from 'react-router-dom';
// import Dashboard from './components/pages/Dashboard';
// import Upload from './components/pages/Upload';
// import Settings from './components/pages/Settings';
// import Help from './components/pages/Help'; // You'll need to create a Help page
// import Library from './components/pages/Library'; // You'll need to create a Library page
import Loader from './components/common/Loader'; // Create a Loader component
// Lazy-loaded page components
const Dashboard = lazy(() => import('./components/pages/Dashboard'));
const Upload = lazy(() => import('./components/pages/Upload'));
const Library = lazy(() => import('./components/pages/Library'));
const Settings = lazy(() => import('./components/pages/Settings'));
const Help = lazy(() => import('./components/pages/Help'));
const AppContainer = styled.div`
  max-width: 900px;
  margin: 0 auto;
  padding: 20px;
  background-color: ${({ theme }) => theme.colors.background};
  border-radius: 10px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
`;
// function App() {
//   const [uploadedFiles, setUploadedFiles] = useState([]);
//   const [notification, setNotification] = useState({ message: '', type: '' }); // Define notification state
//   // Fetch uploaded files when the app loads
//   useEffect(() => {
//     fetch('/api/file_history')
//       .then((response) => response.json())
//       .then((data) => {
//         if (data.files) {
//           setUploadedFiles(data.files);
//         }
//       })
//       .catch((error) => console.error('Error fetching files:', error));
//   }, []);
//   return (
//     <ThemeProvider theme={theme}>
//       <GlobalStyle />
//       <ErrorBoundary>
//         <Container>
//           <h1>Audio/Video Waveform Analyzer</h1>
//           {/* Display Notification if exists */}
//           {notification.message && (
//             <Notification 
//               message={notification.message} 
//               type={notification.type} 
//               onClose={() => setNotification({ message: '', type: '' })} 
//             />
//           )}
//           <FileUploader 
//             setUploadedFiles={setUploadedFiles} 
//             setNotification={setNotification} 
//           />
//           <FileDashboard uploadedFiles={uploadedFiles} />
//         </Container>
//       </ErrorBoundary>
//     </ThemeProvider>
//   );
// }
// export default App;
function App() {
  return (
    <ThemeProvider theme={theme}>
      <GlobalStyle />
      <ErrorBoundary>
        <AppContainer>
          <Layout>
            <Suspense fallback={<Loader />}>
            <Routes>
            <Route path="/" element={<Navigate to="/dashboard" replace />} />
              <Route path="/dashboard" element={<Dashboard />} />
              <Route path="/upload" element={<Upload />} />
              <Route path="/library" element={<Library />} />
              <Route path="/analysis" element={<div>Analysis Page (To Be Implemented)</div>} />
              <Route path="/settings" element={<Settings />} />
              <Route path="/help" element={<Help />} />
              <Route path="*" element={<div>404 - Page Not Found</div>} />
            </Routes>
            </Suspense>
          </Layout>
        </AppContainer>
      </ErrorBoundary>
    </ThemeProvider>
  );
}
export default App;
```

## File: src/styles/theme.js

```js
// src/styles/theme.js
export const theme = {
  colors: {
    primary: '#1E90FF',      // Ocean Blue
    secondary: '#FFA500',    // Vibrant Orange
    accent: '#32CD32',       // Lime Green
    neutral: '#FFFFFF',      // White
    background: '#F5F5F5',   // Light Gray
    text: '#2F4F4F',         // Dark Slate Gray
    success: '#50C878',      // Emerald Green
    error: '#DC143C',        // Crimson Red
    warning: '#DAA520',      // Goldenrod
  },
  fonts: {
    primary: 'Roboto, sans-serif',
    secondary: 'Montserrat, sans-serif',
  },
  fontSizes: {
    h1: '32px',
    h2: '24px',
    h3: '18px',
    body: '14px',
    small: '12px',
  },
};
```

## File: src/styles/GlobalStyle.js

```js
// src/styles/GlobalStyle.js
import { createGlobalStyle } from 'styled-components';
const GlobalStyle = createGlobalStyle`
  body {
    margin: 0;
    padding: 0;
    background-color: ${({ theme }) => theme.colors.background};
    color: ${({ theme }) => theme.colors.text};
    font-family: ${({ theme }) => theme.fonts.primary};
    font-size: ${({ theme }) => theme.fontSizes.body};
    line-height: 1.5;
  }
  h1 {
    font-size: ${({ theme }) => theme.fontSizes.h1};
    font-weight: bold;
  }
  h2 {
    font-size: ${({ theme }) => theme.fontSizes.h2};
    font-weight: 600;
  }
  h3 {
    font-size: ${({ theme }) => theme.fontSizes.h3};
    font-weight: 500;
  }
  p {
    font-size: ${({ theme }) => theme.fontSizes.body};
    font-weight: 400;
  }
  .small-text {
    font-size: ${({ theme }) => theme.fontSizes.small};
    font-weight: 300;
  }
  button {
    font-size: ${({ theme }) => theme.fontSizes.body};
    font-weight: 500;
  }
  /* Focus Styles for Accessibility */
  button:focus {
    outline: 2px solid ${({ theme }) => theme.colors.primary};
    outline-offset: 2px;
  }
  /* Additional Global Styles */
  a {
    font-weight: 500;
    color: ${({ theme }) => theme.colors.primary};
    text-decoration: none;
  }
  a:hover {
    color: ${({ theme }) => theme.colors.secondary};
  }
`;
export default GlobalStyle;
```

## File: src/components/common/VideoPlayer.jsx

```jsx
// src/components/common/VideoPlayer.jsx
import React, { useRef, useState } from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
// Styled Components
const VideoPlayerContainer = styled.div`
  margin-top: 30px;
  padding: 20px;
  background-color: ${({ theme }) => theme.colors.background};
  border-radius: 10px;
  text-align: center;
  position: relative;
`;
const Video = styled.video`
  width: 100%;
  max-width: 800px;
  border-radius: 5px;
`;
const Controls = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 15px;
  button {
    margin: 0 10px;
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background-color: ${({ theme }) => theme.colors.primary};
    color: white;
    transition: background-color 0.2s ease;
    &:hover {
      background-color: ${({ theme }) => theme.colors.secondary};
    }
  }
  button.loop-active {
    background-color: #e74c3c; /* Red color to indicate active loop */
  }
`;
const CloseButton = styled.button`
  margin-top: 15px;
  background-color: ${({ theme }) => theme.colors.error};
  border: none;
  color: white;
  padding: 8px 15px;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s ease;
  &:hover {
    background-color: #c0392b;
  }
`;
// VideoPlayer Component
function VideoPlayer({ 
  fileUrl, 
  fileName, 
  fileType, 
  fileSize, 
  duration = '', // Default value
  onClose 
}) {
  const videoRef = useRef(null);
  const [isLooping, setIsLooping] = useState(false);
  const handleError = (e) => {
    console.error('Video playback error:', e);
    onClose(); // Close the media player on error
  };
  const handleFullscreen = () => {
    if (videoRef.current) {
      if (videoRef.current.requestFullscreen) {
        videoRef.current.requestFullscreen();
      } else if (videoRef.current.webkitRequestFullscreen) { /* Safari */
        videoRef.current.webkitRequestFullscreen();
      } else if (videoRef.current.msRequestFullscreen) { /* IE11 */
        videoRef.current.msRequestFullscreen();
      }
    }
  };
  const toggleLoop = () => {
    setIsLooping(!isLooping);
    if (videoRef.current) {
      videoRef.current.loop = !isLooping;
    }
  };
  return (
    <VideoPlayerContainer>
      <h3>Now Playing: {fileName}</h3>
      {fileSize && (
        <p>File Size: {(fileSize / (1024 * 1024)).toFixed(2)} MB</p>
      )}
      {duration && <p>Duration: {duration}</p>}
      <Video
        ref={videoRef}
        src={fileUrl}
        controls
        onError={handleError}
        aria-label={`Video player for ${fileName}`}
      >
        Your browser does not support the video tag.
      </Video>
      <Controls>
        <button 
          onClick={handleFullscreen} 
          aria-label="Enter Fullscreen Mode"
        >
          Fullscreen
        </button>
        <button 
          onClick={toggleLoop} 
          aria-label={isLooping ? 'Disable Loop' : 'Enable Loop'}
          className={isLooping ? 'loop-active' : ''}
        >
          {isLooping ? 'Looping' : 'Loop'}
        </button>
      </Controls>
      <CloseButton onClick={onClose} aria-label="Close Video Player">Close</CloseButton>
    </VideoPlayerContainer>
  );
}
VideoPlayer.propTypes = {
  fileUrl: PropTypes.string.isRequired,
  fileName: PropTypes.string.isRequired,
  fileType: PropTypes.string.isRequired,
  fileSize: PropTypes.number.isRequired,
  duration: PropTypes.string,
  onClose: PropTypes.func.isRequired,
};
export default VideoPlayer;
```

## File: src/components/common/PreviewSection.jsx

```jsx
// frontend/src/components/common/PreviewSection.jsx
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
const PreviewContainer = styled.div`
  margin-top: 20px;
`;
const PreviewItem = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: ${({ theme }) => theme.colors.background};
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
  margin-bottom: 10px;
`;
const FileInfo = styled.div`
  display: flex;
  flex-direction: column;
`;
const RemoveButton = styled.button`
  background-color: ${({ theme }) => theme.colors.error};
  border: none;
  color: white;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;
  &:hover {
    background-color: #c0392b;
  }
`;
function PreviewSection({ selectedFiles, removeFile }) {
  return (
    <PreviewContainer>
      <h3>Selected Files</h3>
      {selectedFiles.map((file, index) => (
        <PreviewItem key={index}>
          <FileInfo>
            <span><strong>{file.name}</strong></span>
            <span>{(file.size / (1024 * 1024)).toFixed(2)} MB</span>
          </FileInfo>
          <RemoveButton onClick={() => removeFile(index)}>Remove</RemoveButton>
        </PreviewItem>
      ))}
    </PreviewContainer>
  );
}
PreviewSection.propTypes = {
  selectedFiles: PropTypes.arrayOf(PropTypes.object).isRequired,
  removeFile: PropTypes.func.isRequired,
};
export default PreviewSection;
```

## File: src/components/common/Layout.jsx

```jsx
// src/components/common/Layout.jsx
import React, { useState } from "react";
import styled from "styled-components";
import SideNav from "./SideNav";
import Breadcrumbs from "./Breadcrumbs";
import QuickAccessToolbar from "./QuickAccessToolbar";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faBars } from "@fortawesome/free-solid-svg-icons";
import PropTypes from "prop-types";
// Styled Components
const LayoutContainer = styled.div`
  display: flex;
`;
const Content = styled.main`
  margin-left: ${({ sidebarCollapsed }) =>
    sidebarCollapsed ? "60px" : "240px"};
  padding: 20px;
  width: 100%;
  transition: margin-left 0.3s ease-in-out;
  @media (max-width: 768px) {
    margin-left: 0;
  }
`;
const MobileHeader = styled.header`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 60px;
  background-color: #2c3e50;
  color: #ecf0f1;
  display: none;
  align-items: center;
  padding: 0 20px;
  z-index: 1100;
  @media (max-width: 768px) {
    display: flex;
  }
`;
const MenuButton = styled.button`
  background: none;
  border: none;
  color: inherit;
  font-size: 1.5em;
  cursor: pointer;
  outline: none;
  &:hover {
    color: #3498db;
  }
`;
const ToolbarPlaceholder = styled.div`
  margin-top: 60px;
  @media (min-width: 769px) {
    margin-top: 0;
  }
`;
// Component
function Layout({ children }) {
  const [isMobileOpen, setIsMobileOpen] = useState(false);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  const toggleMobile = () => {
    setIsMobileOpen(!isMobileOpen);
  };
  const toggleSidebar = () => {
    setSidebarCollapsed(!sidebarCollapsed);
  };
  return (
    <>
      <SideNav
        isMobile={false}
        isMobileOpen={isMobileOpen}
        toggleMobile={toggleMobile}
        collapsed={sidebarCollapsed}
        toggleSidebar={toggleSidebar}
      />
      <MobileHeader>
        <MenuButton onClick={toggleMobile} aria-label="Open Sidebar">
          <FontAwesomeIcon icon={faBars} />
        </MenuButton>
        <h2 style={{ marginLeft: "20px" }}>WaveAnalyzer</h2>
      </MobileHeader>
      <LayoutContainer>
        {/* <SideNav
          isMobile={false}
          isMobileOpen={false}
          toggleMobile={toggleMobile}
          collapsed={sidebarCollapsed}
          toggleSidebar={toggleSidebar}
        /> */}
        <Content $sidebarCollapsed={sidebarCollapsed}>
          <Breadcrumbs />
          <QuickAccessToolbar />
          <ToolbarPlaceholder />
          {children}
        </Content>
      </LayoutContainer>
    </>
  );
}
Layout.propTypes = {
  children: PropTypes.node.isRequired,
};
export default Layout;
```

## File: src/components/common/FileUploader.jsx

```jsx
// src/components/common/FileUploader.jsx
import React, { useState, useRef } from 'react';
import styled from 'styled-components';
import PreviewSection from './PreviewSection';
import ProgressBar from './ProgressBar';
import Button from './Button'; // Ensure this component exists
import { faUpload } from '@fortawesome/free-solid-svg-icons';
import PropTypes from 'prop-types';
import { ErrorMessage } from './Messages'; // Import only ErrorMessage
const UploadSection = styled.div`
  margin-top: 20px;
`;
const OverwritePrompt = styled.div`
  background-color: ${({ theme }) => theme.colors.background};
  padding: 15px;
  border: 1px solid ${({ theme }) => theme.colors.warning};
  border-radius: 5px;
  margin-top: 20px;
  p {
    margin-bottom: 15px;
    color: ${({ theme }) => theme.colors.text};
    font-size: ${({ theme }) => theme.fontSizes.body};
  }
`;
// New styled component for button container
const OverwriteButtons = styled.div`
  display: flex;
  justify-content: center;
  gap: 10px; /* Space between buttons */
  button {
    flex: 1; /* Ensure both buttons take equal space */
  }
`;
const DropZone = styled.div`
  border: 2px dashed #bbb;
  border-radius: 12px;
  background-color: ${({ theme }) => theme.colors.neutral};
  padding: 40px;
  text-align: center;
  transition: background-color 0.3s ease, box-shadow 0.2s ease;
  cursor: pointer;
  &:hover, &.drag-over {
    background-color: ${({ theme }) => theme.colors.background};
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  }
  i {
    font-size: 50px;
    color: ${({ theme }) => theme.colors.primary};
    margin-bottom: 10px;
  }
  p {
    color: ${({ theme }) => theme.colors.text};
    font-size: ${({ theme }) => theme.fontSizes.body};
  }
`;
function FileUploader({ setUploadedFiles, setNotification }) {
  const [selectedFiles, setSelectedFiles] = useState([]);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [errorMessages, setErrorMessages] = useState([]); // Changed to array
  const [isUploading, setIsUploading] = useState(false);
  const [overwritePrompt, setOverwritePrompt] = useState(false);
  const [overwriteFile, setOverwriteFile] = useState(null);
  const fileInputRef = useRef(null);
  // Handle file selection from input or drag-and-drop
  const handleFiles = (event) => {
    event.preventDefault();
    event.stopPropagation();
    setErrorMessages([]);
    setNotification({ message: '', type: '' });
    let files;
    if (event.type === 'drop') {
      files = event.dataTransfer.files;
    } else {
      files = event.target.files;
    }
    if (files.length === 0) {
      setErrorMessages(['No files selected.']);
      return;
    }
    const allowedMimeTypes = [
      'audio/mpeg',
      'audio/wav',
      'video/mp4',
      'video/x-msvideo',
      'video/quicktime' // Include quicktime to allow .mov files
    ];
    const invalidTypeFiles = Array.from(files).filter(
      file => !allowedMimeTypes.includes(file.type)
    );
    const oversizedFiles = Array.from(files).filter(
      file => file.size > 200 * 1024 * 1024 // 200MB
    );
    let newErrorMessages = [];
    if (invalidTypeFiles.length > 0) {
      newErrorMessages.push(`Unsupported file types: ${invalidTypeFiles.map(f => f.name).join(', ')}`);
    }
    if (oversizedFiles.length > 0) {
      newErrorMessages.push(`Files too large (max 200MB): ${oversizedFiles.map(f => f.name).join(', ')}`);
    }
    if (newErrorMessages.length > 0) {
      setErrorMessages(newErrorMessages);
      return;
    }
    setSelectedFiles((prevFiles) => [...prevFiles, ...Array.from(files)]);
  };
  // Prevent default behavior in drag events
  const handleDragOver = (event) => {
    event.preventDefault();
    event.stopPropagation();
  };
  const handleDrop = (event) => {
    event.preventDefault();
    event.stopPropagation();
    handleFiles(event);
  };
  // Check if the file already exists
  const checkFileExists = async (fileName) => {
    try {
      const response = await fetch(`/api/file_exists?filename=${encodeURIComponent(fileName)}`);
      const data = await response.json();
      return data.exists;
    } catch (error) {
      console.error('Error checking file existence:', error);
      return false;
    }
  };
  // Handle file upload to the server
  const uploadFiles = async () => {
    if (selectedFiles.length === 0) {
      setErrorMessages(['Please select files to upload.']);
      return;
    }
    const fileExists = await checkFileExists(selectedFiles[0].name);
    if (fileExists) {
      setOverwritePrompt(true);
      setOverwriteFile(selectedFiles[0].name);
      return;
    }
    handleUpload(selectedFiles);
  };
  const handleUpload = async (files) => {
    setIsUploading(true);
    setUploadProgress(0);
    setErrorMessages([]);
    const formData = new FormData();
    files.forEach((file) => {
      formData.append('file', file);
    });
    //   const xhr = new XMLHttpRequest();
    //   xhr.upload.addEventListener('progress', (event) => {
    //     if (event.lengthComputable) {
    //       const percentComplete = Math.round((event.loaded / event.total) * 100);
    //       setUploadProgress(percentComplete);
    //     }
    //   });
    //   xhr.onreadystatechange = () => {
    //     if (xhr.readyState === 4) {
    //       setIsUploading(false);
    //       setUploadProgress(0);
    //       if (xhr.status === 200 || xhr.status === 207) {
    //         const response = JSON.parse(xhr.responseText);
    //         if (response.uploaded_files) {
    //           setNotification({ message: 'Files uploaded successfully!', type: 'success' });
    //         }
    //         if (response.errors) {
    //           const newErrors = response.errors.map(err => `${err.filename}: ${err.error}`);
    //           setErrorMessages(newErrors);
    //         }
    //         setSelectedFiles([]);
    //         fetch('/api/file_history')
    //           .then((res) => res.json())
    //           .then((data) => {
    //             if (data.files) {
    //               setUploadedFiles(data.files);
    //             }
    //           })
    //           .catch((error) => console.error('Error fetching files:', error));
    //       } else if (xhr.status === 413) {
    //         const response = JSON.parse(xhr.responseText);
    //         setErrorMessages([`${response.error}: ${response.message}`]);
    //       } else {
    //         setNotification({ message: 'Error uploading files. Please try again.', type: 'error' });
    //         console.error('Error uploading files:', xhr.responseText);
    //       }
    //     }
    //   };
    //   xhr.open('POST', '/upload');
    //   xhr.send(formData);
    // };
    try {
      const response = await fetch('/upload', {
        method: 'POST',
        body: formData,
      });
      // Calculate upload progress manually since fetch doesn't provide progress updates
      // For more advanced progress tracking, consider using Axios
      const data = await response.json();
      if (response.ok || response.status === 207) {
        if (data.uploaded_files) {
          setNotification({ message: 'Files uploaded successfully!', type: 'success' });
        }
        if (data.errors) {
          const newErrors = data.errors.map(err => `${err.filename}: ${err.error}`);
          setErrorMessages(newErrors);
        }
        setSelectedFiles([]);
        const historyResponse = await fetch('/api/file_history');
        const historyData = await historyResponse.json();
        if (historyData.files) {
          setUploadedFiles(historyData.files);
        }
      } else if (response.status === 413) {
        const errorData = await response.json();
        setErrorMessages([`${errorData.error}: ${errorData.message}`]);
      } else {
        setNotification({ message: 'Error uploading files. Please try again.', type: 'error' });
        console.error('Error uploading files:', data);
      }
    } catch (error) {
      setNotification({ message: 'Network error during file upload.', type: 'error' });
      console.error('Network error:', error);
    } finally {
      setIsUploading(false);
      setUploadProgress(0);
    }
  };
  // Remove selected files
  const removeFile = (index) => {
    setSelectedFiles((prevFiles) => prevFiles.filter((_, i) => i !== index));
  };
  return (
    <UploadSection>
      {/* Drop zone for files */}
      <DropZone
        role="button"
        aria-label="File Upload Zone"
        onDragOver={handleDragOver}
        onDragEnter={handleDragOver}
        onDragLeave={handleDragOver}
        onDrop={handleDrop}
        onClick={() => fileInputRef.current.click()}
        className={isUploading ? 'disabled' : ''}
      >
        <i className="fas fa-cloud-upload-alt"></i>
        <p>Click here or drag and drop audio or video files (max 200MB)</p>
        <input
          type="file"
          id="file-input"
          accept="audio/*,video/*"
          multiple
          style={{ display: 'none' }}
          onChange={handleFiles}
          ref={fileInputRef}
        />
      </DropZone>
      {/* Display selected files */}
      {selectedFiles.length > 0 && (
        <>
          <PreviewSection
            selectedFiles={selectedFiles}
            removeFile={removeFile}
          />
          <Button
            variant="primary"
            icon={faUpload}
            onClick={uploadFiles}
            disabled={isUploading}
            aria-label={isUploading ? 'Uploading files' : 'Upload Files'}
          >
            {isUploading ? 'Uploading...' : 'Upload Files'}
          </Button>
          <ProgressBar progress={uploadProgress} />
        </>
      )}
      {/* Display error messages */}
      {errorMessages.length > 0 && (
        <ErrorMessage>
          {errorMessages.map((msg, index) => (
            <p key={index}>{msg}</p>
          ))}
        </ErrorMessage>
      )}
      {/* Overwrite Prompt */}
      {overwritePrompt && (
        <OverwritePrompt>
          <p>File "{overwriteFile}" already exists. Do you want to overwrite it?</p>
          <OverwriteButtons>
            <Button
              variant="secondary"
              customColor="#2ecc71" /* Transient props are handled inside the Button component */
              onClick={() => {
                handleUpload(selectedFiles);
                setOverwritePrompt(false);
              }}
              aria-label="Yes, overwrite the existing file"
            >
              Yes
            </Button>
            <Button
              variant="secondary"
              customColor="#e74c3c"
              onClick={() => setOverwritePrompt(false)}
              aria-label="No, cancel the upload"
            >
              No
            </Button>
          </OverwriteButtons>
        </OverwritePrompt>
      )}
    </UploadSection>
  );
}
FileUploader.propTypes = {
  setUploadedFiles: PropTypes.func.isRequired,
  setNotification: PropTypes.func.isRequired,
};
export default FileUploader;
```

## File: src/components/common/ErrorBoundary.jsx

```jsx
// src/components/common/ErrorBoundary.jsx
import React from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
const FallbackContainer = styled.div`
  padding: 20px;
  background-color: ${({ theme }) => theme.colors.error};
  color: white;
  border-radius: 5px;
  text-align: center;
`;
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true };
  }
  componentDidCatch(error, errorInfo) {
    console.error('Error Boundary Caught an error:', error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return <FallbackContainer>Something went wrong.</FallbackContainer>;
    }
    return this.props.children; 
  }
}
ErrorBoundary.propTypes = {
  children: PropTypes.node.isRequired,
};
export default ErrorBoundary;
```

## File: src/components/common/MediaPlayer.jsx

```jsx
// src/components/common/MediaPlayer.jsx
import React, { useEffect, useRef, useState } from 'react';
import AudioPlayer from './AudioPlayer';
import VideoPlayer from './VideoPlayer';
import styled, { keyframes } from 'styled-components';
import PropTypes from 'prop-types';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faForward, faBackward, faTimes } from '@fortawesome/free-solid-svg-icons';
import { faPlay, faPause, faStop, faRedo, faVolumeUp, faVolumeMute } from '@fortawesome/free-solid-svg-icons';
import FocusTrap from 'focus-trap-react';
// Keyframes for fade-in animation
const fadeIn = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;
// Styled Components for Modal
const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000; /* Above other elements */
  animation: ${fadeIn} 0.3s ease-out;
`;
const ModalContent = styled.div`
  background-color: ${({ theme }) => theme.colors.background};
  padding: 20px;
  border-radius: 10px;
  width: 90%;
  max-width: 800px;
  position: relative;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  max-height: 90vh;
  overflow-y: auto;
  @media (max-width: 767px) {
    padding: 15px;
    width: 95%;
    max-width: 100%;
    border-radius: 0;
    height: 100vh;
    max-height: 100vh;
  }
`;
const CloseIcon = styled(FontAwesomeIcon)`
  position: absolute;
  top: 15px;
  right: 15px;
  cursor: pointer;
  color: ${({ theme }) => theme.colors.error};
  font-size: 1.5rem;
  &:hover {
    color: #c0392b;
  }
  @media (max-width: 767px) {
    top: 10px;
    right: 10px;
    font-size: 1.2rem;
  }
`;
const NavigationControls = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 20px;
  button {
    margin: 0 15px;
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background-color: ${({ theme }) => theme.colors.primary};
    color: white;
    transition: background-color 0.2s ease;
    &:hover {
      background-color: ${({ theme }) => theme.colors.secondary};
    }
  }
  @media (max-width: 767px) {
    button {
      padding: 6px 10px;
      margin: 0 10px;
    }
  }
`;
// MediaPlayer Component as Modal
function MediaPlayer({ 
  fileUrl, 
  fileName, 
  fileType, 
  fileSize, 
  duration = '', // Default value
  onClose, 
  onNextTrack, 
  onPrevTrack 
}) {
  const closeButtonRef = useRef(null);
  useEffect(() => {
    if (closeButtonRef.current) {
      closeButtonRef.current.focus();
    }
  }, []);
  return (
    <ModalOverlay onClick={onClose} aria-modal="true" role="dialog">
      <FocusTrap>
        <ModalContent onClick={(e) => e.stopPropagation()}>
          <CloseIcon icon={faTimes} onClick={onClose} aria-label="Close Media Player" ref={closeButtonRef} />
          {fileType && fileType.startsWith('audio/') ? (
            <AudioPlayer
              fileUrl={fileUrl}
              fileName={fileName}
              fileType={fileType}
              fileSize={fileSize}
              duration={duration}
              onClose={onClose}
            />
          ) : (
            <VideoPlayer
              fileUrl={fileUrl}
              fileName={fileName}
              fileType={fileType}
              fileSize={fileSize}
              duration={duration}
              onClose={onClose}
            />
          )}
          {/* Navigation Controls */}
          <NavigationControls>
            <button onClick={onPrevTrack} aria-label="Previous Track">
              <FontAwesomeIcon icon={faBackward} /> Previous
            </button>
            <button onClick={onNextTrack} aria-label="Next Track">
              Next <FontAwesomeIcon icon={faForward} />
            </button>
          </NavigationControls>
        </ModalContent>
      </FocusTrap>
    </ModalOverlay>
  );
}
MediaPlayer.propTypes = {
  fileUrl: PropTypes.string.isRequired,
  fileName: PropTypes.string.isRequired,
  fileType: PropTypes.string.isRequired,
  fileSize: PropTypes.number.isRequired,
  duration: PropTypes.string,
  onClose: PropTypes.func.isRequired,
  onNextTrack: PropTypes.func.isRequired,
  onPrevTrack: PropTypes.func.isRequired,
};
export default MediaPlayer;
```

## File: src/components/common/Button.jsx

```jsx
// src/components/common/Button.jsx
import React from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
// Transient Props: $variant, $customColor
const ButtonStyled = styled.button`
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  font-size: ${({ theme }) => theme.fontSizes.body || '16px'};
  cursor: pointer;
  /* Use transient props by prefixing with $ */
  background-color: ${({ $variant, $customColor, theme }) =>
    $customColor
      ? $customColor
      : $variant === 'primary'
      ? theme.colors.primary || '#3498db'
      : $variant === 'secondary'
      ? theme.colors.secondary || '#2ecc71'
      : theme.colors.neutral || '#95a5a6'};
  color: ${({ $variant, theme }) =>
    $variant === 'tertiary' ? theme.colors.text || '#2c3e50' : '#fff'};
  display: flex;
  align-items: center;
  justify-content: center;
  &:hover {
    opacity: 0.9;
  }
  &:disabled {
    background-color: #ccc;
    cursor: not-allowed;
  }
  /* Focus Styles */
  &:focus {
    outline: 2px solid ${({ theme }) => theme.colors.primary || '#3498db'};
    outline-offset: 2px;
  }
`;
// Button Component
const Button = ({ 
  variant = 'primary', 
  children, 
  onClick = () => {}, 
  disabled = false, 
  icon = null, 
  type = 'button',
  customColor = null
}) => (
  <ButtonStyled 
    /* Use transient props by prefixing with $ */
    $variant={variant} 
    onClick={onClick} 
    disabled={disabled} 
    type={type} 
    $customColor={customColor} 
    aria-label={typeof children === "string" ? children : undefined}
  >
    {icon && <FontAwesomeIcon icon={icon} style={{ marginRight: children ? "8px" : "0" }} />}
    {children}
  </ButtonStyled>
);
Button.propTypes = {
  variant: PropTypes.oneOf(['primary', 'secondary', 'tertiary']),
  children: PropTypes.node,
  onClick: PropTypes.func,
  disabled: PropTypes.bool,
  icon: PropTypes.object, // FontAwesomeIcon expects an icon object
  type: PropTypes.oneOf(['button', 'submit', 'reset']),
  customColor: PropTypes.string, // New prop type
};
export default Button;
```

## File: src/components/common/Notification.jsx

```jsx
// frontend/src/components/common/Notification.jsx
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import { faTimes } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
const NotificationContainer = styled.div`
  background-color: ${({ $type, theme }) => 
    $type === 'success' ? theme.colors.success :
    $type === 'error' ? theme.colors.error :
    theme.colors.warning};
  color: white;
  padding: 15px 20px;
  border-radius: 5px;
  position: relative;
  margin-top: 20px;
`;
const CloseButton = styled.button`
  position: absolute;
  top: 10px;
  right: 10px;
  background: transparent;
  border: none;
  color: white;
  cursor: pointer;
`;
function Notification({ message, type = 'success', onClose }) {
  return (
    <NotificationContainer $type={type} role="alert" aria-live="assertive">
      <span>{message}</span>
      <CloseButton onClick={onClose} aria-label="Close Notification">
        <FontAwesomeIcon icon={faTimes} />
      </CloseButton>
    </NotificationContainer>
  );
}
Notification.propTypes = {
  message: PropTypes.string.isRequired,
  type: PropTypes.oneOf(['success', 'error', 'warning']),
  onClose: PropTypes.func.isRequired,
};
export default Notification;
```

## File: src/components/common/WaveformViewer.jsx

```jsx
// src/components/common/WaveformViewer.jsx
import React, { useEffect, useRef } from 'react';
import WaveSurfer from 'wavesurfer.js';
import styled from 'styled-components';
const WaveformViewerContainer = styled.div`
  margin-top: 20px;
  background-color: ${({ theme }) => theme.colors.neutral};
  padding: 20px;
  border-radius: 10px;
`;
const Waveform = styled.div`
  width: 100%;
  height: 150px;
`;
function WaveformViewer({ fileUrl }) {
  const waveformRef = useRef(null);
  const wavesurferRef = useRef(null);
  const resizeTimeout = useRef(null);
  useEffect(() => {
    if (waveformRef.current && fileUrl) {
      wavesurferRef.current = WaveSurfer.create({
        container: waveformRef.current,
        waveColor: '#D9DCFF',
        progressColor: '#4353FF',
        cursorColor: '#4353FF',
        responsive: true,
        height: 150,
        barWidth: 2,
        barRadius: 3,
        backend: 'WebAudio',
      });
      wavesurferRef.current.load(fileUrl);
      // Handle errors
      wavesurferRef.current.on('error', (error) => {
        console.error('WaveSurfer error:', error);
      });
      // Debounced resize handler
      const handleResize = () => {
        clearTimeout(resizeTimeout.current);
        resizeTimeout.current = setTimeout(() => {
          if (wavesurferRef.current) {
            wavesurferRef.current.empty();
            wavesurferRef.current.drawBuffer();
          }
        }, 300);
      };
      window.addEventListener('resize', handleResize);
      return () => {
        window.removeEventListener('resize', handleResize);
        clearTimeout(resizeTimeout.current);
        if (wavesurferRef.current) {
          wavesurferRef.current.destroy();
        }
      };
    }
  }, [fileUrl]);
  return (
    <WaveformViewerContainer>
      <h3>Waveform Preview</h3>
      <Waveform id="waveform-viewer" ref={waveformRef} aria-label="Audio waveform visualization"></Waveform>
    </WaveformViewerContainer>
  );
}
WaveformViewer.propTypes = {
  fileUrl: PropTypes.string.isRequired,
};
export default WaveformViewer;
```

## File: src/components/common/Messages.jsx

```jsx
// frontend/src/components/common/Messages.jsx
import styled from 'styled-components';
import PropTypes from 'prop-types';
// Error Message Component
export const ErrorMessage = styled.div.attrs({
  role: 'alert',
  'aria-live': 'assertive',
})`
  color: ${({ theme }) => theme.colors.error};
  background-color: #ffe6e6;
  padding: 10px 15px;
  border: 1px solid ${({ theme }) => theme.colors.error};
  border-radius: 5px;
  margin-top: 10px;
`;
ErrorMessage.propTypes = {
  children: PropTypes.node.isRequired,
};
```

## File: src/components/common/QuickAccessToolbar.jsx

```jsx
// src/components/common/QuickAccessToolbar.jsx
import React, { useState, useEffect, useRef } from "react";
import styled from "styled-components";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import {
  faFile,
  faChartLine,
  faUpload,
  faPlus,
  faTimes,
  faGripVertical,
} from "@fortawesome/free-solid-svg-icons";
import Button from "./Button";
import Tooltip from "./Tooltip";
import {
  DndContext,
  closestCenter,
  PointerSensor,
  useSensor,
  useSensors,
} from "@dnd-kit/core";
import {
  arrayMove,
  SortableContext,
  useSortable,
  sortableKeyboardCoordinates,
  horizontalListSortingStrategy,
} from "@dnd-kit/sortable";
import { CSS } from "@dnd-kit/utilities";
// Styled Components
const ToolbarContainer = styled.div`
  display: flex;
  padding: 10px 20px;
  background-color: #bdc3c7;
  align-items: center;
`;
const DraggableArea = styled.div`
  display: flex;
  align-items: center;
  flex-grow: 1;
`;
const SortableItemContainer = styled.div`
  display: flex;
  align-items: center;
  margin-right: 15px;
  padding: 5px;
  background-color: ${(props) =>
    props.isDragging ? "#f0f0f0" : "transparent"};
  border-radius: 4px;
`;
const DragHandleStyled = styled.div`
  cursor: grab;
  color: #888;
  margin-right: 8px;
  &:active {
    cursor: grabbing;
  }
  &:hover {
    color: #333;
  }
`;
const OverflowMenu = styled.div`
  position: relative;
`;
const OverflowButton = styled(Button)`
  /* You can add additional styles if needed */
`;
const OverflowContent = styled.div`
  position: absolute;
  right: 0;
  top: 100%;
  background-color: #ecf0f1;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2);
  border-radius: 4px;
  display: ${({ $open }) => ($open ? "block" : "none")};
  z-index: 1000;
`;
const OverflowItem = styled.button`
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: flex;
  align-items: center;
  width: 100%;
  text-align: left;
  border: none;
  background: none;
  cursor: pointer;
  &:hover {
    background-color: #ddd;
  }
`;
// SortableItem Component
function SortableItem({ id, item, removeItem }) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id });
  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    zIndex: isDragging ? 2 : 1,
  };
  return (
    <SortableItemContainer ref={setNodeRef} style={style} isDragging={isDragging}>
      <DragHandleStyled {...attributes} {...listeners}>
        <FontAwesomeIcon icon={faGripVertical} />
      </DragHandleStyled>
      <Tooltip $text={item.label}>
        <Button
          variant="secondary"
          icon={item.icon}
          onClick={item.action}
          aria-label={item.label}
        >
          {item.label}
        </Button>
      </Tooltip>
      <Button
        variant="tertiary"
        icon={faTimes}
        onClick={() => removeItem(item.id)}
        aria-label={`Remove ${item.label}`}
      />
    </SortableItemContainer>
  );
}
// Main QuickAccessToolbar Component
function QuickAccessToolbar() {
  const [pinnedItems, setPinnedItems] = useState([]);
  const [overflowOpen, setOverflowOpen] = useState(false);
  const overflowRef = useRef(null);
  const availableItems = [
    {
      id: "1",
      icon: faFile,
      label: "Recent File",
      action: () => console.log("Recent File clicked"),
    },
    {
      id: "2",
      icon: faChartLine,
      label: "Sentiment Analysis",
      action: () => console.log("Sentiment Analysis clicked"),
    },
    {
      id: "3",
      icon: faUpload,
      label: "Upload New File",
      action: () => console.log("Upload New File clicked"),
    },
    // Add more items as needed
  ];
  // Load pinned items from localStorage on mount
  useEffect(() => {
    const savedItems = localStorage.getItem("quickAccess");
    if (savedItems) {
      setPinnedItems(JSON.parse(savedItems));
    } else {
      // Optionally, initialize with default items
      setPinnedItems(availableItems.slice(0, 2)); // Example: first two items
    }
  }, []);
  // Save pinned items to localStorage whenever they change
  useEffect(() => {
    localStorage.setItem("quickAccess", JSON.stringify(pinnedItems));
  }, [pinnedItems]);
  // Handle clicks outside the overflow menu to close it
  useEffect(() => {
    function handleClickOutside(event) {
      if (
        overflowRef.current &&
        !overflowRef.current.contains(event.target)
      ) {
        setOverflowOpen(false);
      }
    }
    document.addEventListener("mousedown", handleClickOutside);
    return () =>
      document.removeEventListener("mousedown", handleClickOutside);
  }, []);
  // Add a new item to pinnedItems
  const addItem = (item) => {
    if (pinnedItems.length < availableItems.length) {
      setPinnedItems([...pinnedItems, item]);
    }
  };
  // Remove an item from pinnedItems
  const removeItem = (id) => {
    setPinnedItems(pinnedItems.filter((item) => item.id !== id));
  };
  // Initialize sensors for @dnd-kit
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 5, // Start dragging after moving 5 pixels
      },
    })
  );
  // Handle drag end event
  const handleDragEnd = (event) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      const oldIndex = pinnedItems.findIndex((item) => item.id === active.id);
      const newIndex = pinnedItems.findIndex((item) => item.id === over.id);
      setPinnedItems((items) => arrayMove(items, oldIndex, newIndex));
    }
  };
  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragEnd={handleDragEnd}
    >
      <ToolbarContainer>
        <SortableContext
          items={pinnedItems.map((item) => item.id)}
          strategy={horizontalListSortingStrategy}
        >
          <DraggableArea>
            {pinnedItems.map((item) => (
              <SortableItem
                key={item.id}
                id={item.id}
                item={item}
                removeItem={removeItem}
              />
            ))}
          </DraggableArea>
        </SortableContext>
        {pinnedItems.length < availableItems.length && (
          <OverflowMenu ref={overflowRef}>
            <OverflowButton
              variant="primary"
              icon={faPlus}
              onClick={() => setOverflowOpen(!overflowOpen)}
              aria-label="More Quick Access Options"
              aria-expanded={overflowOpen}
            />
            <OverflowContent $open={overflowOpen}>
              {availableItems
                .filter(
                  (item) =>
                    !pinnedItems.some(
                      (pinned) => pinned.id === item.id
                    )
                )
                .map((item) => (
                  <OverflowItem
                    key={item.id}
                    onClick={() => {
                      addItem(item);
                      setOverflowOpen(false);
                    }}
                  >
                    <FontAwesomeIcon
                      icon={item.icon}
                      style={{ marginRight: "8px" }}
                    />
                    {item.label}
                  </OverflowItem>
                ))}
            </OverflowContent>
          </OverflowMenu>
        )}
      </ToolbarContainer>
    </DndContext>
  );
}
export default QuickAccessToolbar;
```

## File: src/components/common/Loader.jsx

```jsx
// src/components/common/Loader.jsx
import React from 'react';
import styled, { keyframes } from 'styled-components';
const spin = keyframes`
  to { transform: rotate(360deg); }
`;
const LoaderWrapper = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
`;
const Spinner = styled.div`
  border: 4px solid ${({ theme }) => theme.colors.neutral};
  border-top: 4px solid ${({ theme }) => theme.colors.primary};
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: ${spin} 1s linear infinite;
`;
function Loader() {
  return (
    <LoaderWrapper>
      <Spinner />
    </LoaderWrapper>
  );
}
export default Loader;
```

## File: src/components/common/AudioPlayer.jsx

```jsx
// src/components/common/AudioPlayer.jsx
import React, { useEffect, useRef, useReducer, useCallback } from 'react';
import WaveSurfer from 'wavesurfer.js';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faPlay, faPause, faStop, faRedo, faVolumeUp, faVolumeMute } from '@fortawesome/free-solid-svg-icons';
import debounce from 'lodash.debounce'; // Install lodash.debounce if not already installed
// Styled Components
const AudioPlayerContainer = styled.div`
  margin-top: 20px;
  text-align: center;
  background-color: ${({ theme }) => theme.colors.background};
  padding: 20px;
  border-radius: 10px;
    outline: none; /* Ensure focus outline is visible */
`;
const Controls = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 15px;
  button {
    margin: 0 10px;
    padding: 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background-color: ${({ theme }) => theme.colors.primary};
    color: white;
    transition: background-color 0.2s ease;
    &:hover {
      background-color: ${({ theme }) => theme.colors.secondary};
      outline: none;
    }
  }
  label {
    display: flex;
    align-items: center;
    margin: 0 10px;
    color: ${({ theme }) => theme.colors.text};
    font-size: 14px;
  }
  input[type="range"] {
    width: 100px;
    margin-left: 5px;
  }
`;
const CloseButton = styled.button`
  margin-top: 15px;
  background-color: ${({ theme }) => theme.colors.error};
  border: none;
  color: white;
  padding: 8px 15px;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s ease;
  &:hover,
  &:focus {
    background-color: ${({ theme }) => theme.colors.errorHover || '#c0392b'};
    outline: none;
  }
`;
// Define initial state
const initialState = {
  isPlaying: false,
  volume: 1,
  playbackRate: 1,
  loop: false,
  duration: '',
};
// Define reducer
function reducer(state, action) {
  switch (action.type) {
    case 'PLAY_PAUSE':
      return { ...state, isPlaying: !state.isPlaying };
    case 'STOP':
      return { ...state, isPlaying: false };
    case 'SET_VOLUME':
      return { ...state, volume: action.payload };
    case 'SET_PLAYBACK_RATE':
      return { ...state, playbackRate: action.payload };
    case 'TOGGLE_LOOP':
      return { ...state, loop: !state.loop };
    case 'SET_DURATION':
      return { ...state, duration: action.payload };
    default:
      return state;
  }
}
// AudioPlayer Component
function AudioPlayer({
  fileUrl,
  fileName,
  fileType,
  fileSize,
  onClose,
  triggerRef, // New prop
}) {
  const waveformRef = useRef(null);
  const wavesurferRef = useRef(null);
  const [state, dispatch] = useReducer(reducer, initialState);
  const { isPlaying, volume, playbackRate, loop, duration } = state;
  const stateRef = useRef(state);
//   const loopRef = useRef(loop); // Ref to keep track of loop state
//  // Update loopRef whenever loop state changes
//  useEffect(() => {
//   loopRef.current = loop;
// }, [loop]);
// Update stateRef whenever state changes
useEffect(() => {
  stateRef.current = state;
}, [state]);
  // Debounced handlers
  const debouncedSetVolume = useCallback(
    debounce((newVolume) => {
      if (wavesurferRef.current) {
        wavesurferRef.current.setVolume(newVolume);
      }
    }, 300),
    []
  );
  const debouncedSetPlaybackRate = useCallback(
    debounce((newRate) => {
      if (wavesurferRef.current) {
        wavesurferRef.current.setPlaybackRate(newRate);
      }
    }, 300),
    []
  );
  useEffect(() => {
    wavesurferRef.current = WaveSurfer.create({
      container: waveformRef.current,
      waveColor: '#D9DCFF',
      progressColor: '#4353FF',
      cursorColor: '#4353FF',
      responsive: true,
      height: 100,
      cursorWidth: 2,
      barWidth: 2,
    });
    wavesurferRef.current.load(fileUrl);
    wavesurferRef.current.setVolume(volume);
    wavesurferRef.current.setPlaybackRate(playbackRate);
    wavesurferRef.current.on('ready', () => {
      const totalDuration = wavesurferRef.current.getDuration();
      const formattedDuration = new Date(totalDuration * 1000).toISOString().substr(14, 5);
      dispatch({ type: 'SET_DURATION', payload: formattedDuration });
    });
    wavesurferRef.current.on('play', () => dispatch({ type: 'PLAY_PAUSE' }));
    wavesurferRef.current.on('pause', () => dispatch({ type: 'PLAY_PAUSE' }));
    wavesurferRef.current.on('finish', () => {
      dispatch({ type: 'STOP' });
      if (stateRef.current.loop) {
        wavesurferRef.current.play();
      }
    });
    return () => {
      if (wavesurferRef.current) {
        wavesurferRef.current.destroy();
      }
    };
  }, [fileUrl]);
  useEffect(() => {
    if (wavesurferRef.current) {
      wavesurferRef.current.setVolume(volume);
      wavesurferRef.current.setPlaybackRate(playbackRate);
    }
  }, [volume, playbackRate]);
  const playPause = () => {
    dispatch({ type: 'PLAY_PAUSE' });
    wavesurferRef.current?.playPause();
  };
  const stop = () => {
    dispatch({ type: 'STOP' });
    wavesurferRef.current?.stop();
  };
  // const handleVolumeChange = (e) => {
  //   const newVolume = parseFloat(e.target.value);
  //   setVolume(newVolume);
  //   wavesurferRef.current.setVolume(newVolume);
  // };
  // const handlePlaybackRateChange = (e) => {
  //   const newRate = parseFloat(e.target.value);
  //   setPlaybackRate(newRate);
  //   wavesurferRef.current.setPlaybackRate(newRate);
  // };
  const handleVolumeChange = (e) => {
    const newVolume = parseFloat(e.target.value);
    dispatch({ type: 'SET_VOLUME', payload: newVolume });
    debouncedSetVolume(newVolume);
  };
  const handlePlaybackRateChange = (e) => {
    const newRate = parseFloat(e.target.value);
    dispatch({ type: 'SET_PLAYBACK_RATE', payload: newRate });
    debouncedSetPlaybackRate(newRate);
  };
  const toggleLoop = () => {
    dispatch({ type: 'TOGGLE_LOOP' });
  };
  const closePlayer = () => {
    onClose();
    if (triggerRef && triggerRef.current) {
      triggerRef.current.focus();
    }
  };
  return (
<AudioPlayerContainer tabIndex="-1" aria-label="Audio Player">      <h3>Now Playing: {fileName}</h3>
{fileSize && (
        <p>File Size: {(fileSize / (1024 * 1024)).toFixed(2)} MB</p>
      )}
      {duration && <p>Duration: {duration}</p>}
      <div id="waveform" ref={waveformRef} role="region"
        aria-label={`Waveform for ${fileName}`}
        tabIndex="0"
        onKeyDown={(e) => {
          if (e.key === ' ' || e.key === 'Enter') {
            e.preventDefault();
            playPause();          }
          // Implement additional keyboard interactions as needed
        }}
        style={{ position: 'relative' }}>{/* Optional: Add visible focus indicators */}
        <div
          tabIndex="-1"
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
          }}
        ></div></div>
      <Controls>
        <button onClick={playPause} aria-label={isPlaying ? 'Pause' : 'Play'}>
          <FontAwesomeIcon icon={isPlaying ? faPause : faPlay} />
        </button>
        <button onClick={stop} aria-label="Stop">
          <FontAwesomeIcon icon={faStop} />
        </button>
        <button onClick={toggleLoop} aria-label={loop ? 'Disable Loop' : 'Enable Loop'} style={{ backgroundColor: loop ? '#e74c3c' : '' }}>
          <FontAwesomeIcon icon={faRedo} />
        </button>
        <label>
          <FontAwesomeIcon icon={volume > 0 ? faVolumeUp : faVolumeMute} />
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={volume}
            onChange={handleVolumeChange}
            aria-label="Volume Control"
          />
        </label>
        <label>
          Speed:
          <input
            type="range"
            min="0.5"
            max="2"
            step="0.1"
            value={playbackRate}
            onChange={handlePlaybackRateChange}
            aria-label="Playback Speed Control"
          />
        </label>
      </Controls>
      <CloseButton onClick={closePlayer} aria-label="Close Audio Player">
        Close
      </CloseButton>
    </AudioPlayerContainer>
  );
}
AudioPlayer.propTypes = {
  fileUrl: PropTypes.string.isRequired,
  fileName: PropTypes.string.isRequired,
  fileType: PropTypes.string.isRequired,
  fileSize: PropTypes.number.isRequired,
  duration: PropTypes.string,
  onClose: PropTypes.func.isRequired,
  triggerRef: PropTypes.object, // New prop
};
export default AudioPlayer;
```

## File: src/components/common/SideNav.jsx

```jsx
// src/components/common/SideNav.jsx
import React from "react";
import styled from "styled-components";
import { NavLink } from "react-router-dom";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import {
  faHome,
  faUpload,
  faFolder,
  faSearch,
  faCog,
  faQuestionCircle,
  faArrowLeft,
  faArrowRight,
} from "@fortawesome/free-solid-svg-icons";
import Tooltip from "./Tooltip";
import PropTypes from "prop-types";
// Styled Components
const Sidebar = styled.nav`
  position: fixed;
  left: 0;
  top: 0;
  height: 100vh;
  width: ${({ collapsed }) => (collapsed ? "60px" : "240px")};
  background-color: #2c3e50;
  color: #ecf0f1;
  transition: width 0.3s ease-in-out;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  @media (max-width: 1024px) {
    width: ${({ collapsed }) => (collapsed ? "60px" : "200px")};
  }
  @media (max-width: 768px) {
    position: fixed;
    z-index: 1000;
    transform: ${({ isMobileOpen }) =>
      isMobileOpen ? "translateX(0)" : "translateX(-100%)"};
    transition: transform 0.3s ease-in-out;
  }
`;
const Logo = styled.div`
  padding: 20px;
  font-size: 1.5em;
  text-align: center;
  background-color: #1a252f;
`;
const NavItems = styled.ul`
  list-style: none;
  padding: 0;
  margin: 0;
`;
const NavItem = styled.li`
  padding: 15px 20px;
  display: flex;
  align-items: center;
  cursor: pointer;
  &.active,
  &:hover {
    background-color: #4353ff;
  }
  a {
    text-decoration: none;
    color: inherit;
    display: flex;
    align-items: center;
    width: 100%;
  }
  svg {
    margin-right: ${({ collapsed }) => (collapsed ? "0" : "10px")};
    font-size: 1.2em;
  }
  span {
    display: ${({ collapsed }) => (collapsed ? "none" : "inline")};
    white-space: nowrap;
  }
`;
const ToggleButton = styled.button`
  background: none;
  border: none;
  color: inherit;
  padding: 15px;
  cursor: pointer;
  font-size: 1.2em;
  outline: none;
  &:hover {
    background-color: #1a252f;
  }
`;
// Component
function SideNav({
  isMobile = false,
  isMobileOpen = false,
  toggleMobile,
  collapsed = false,
  toggleSidebar,
}) {
  //   const [collapsed, setCollapsed] = useState(false);
  const handleToggle = () => {
    if (isMobile) {
      toggleMobile();
    } else {
      toggleSidebar();
    }
  };
  return (
    <Sidebar
      $collapsed={collapsed}
      $isMobileOpen={isMobileOpen}
      aria-label="Sidebar Navigation"
    >
      <div>
        <Logo>{!collapsed ? "WaveAnalyzer" : "WA"}</Logo>
        <NavItems>
          <NavItem $collapsed={collapsed}>
          <NavLink to="/dashboard" className={({ isActive }) => isActive ? "active" : ""}>
              <FontAwesomeIcon icon={faHome} />
              <span>Dashboard</span>
            </NavLink>
          </NavItem>
          <NavItem $collapsed={collapsed}>
          <NavLink to="/upload" className={({ isActive }) => isActive ? "active" : ""}>
              <FontAwesomeIcon icon={faUpload} />
              <span>Upload</span>
            </NavLink>
          </NavItem>
          <NavItem $collapsed={collapsed}>
          <NavLink to="/library" className={({ isActive }) => isActive ? "active" : ""}>
              <FontAwesomeIcon icon={faFolder} />
              <span>Library</span>
            </NavLink>
          </NavItem>
          <NavItem $collapsed={collapsed}>
          <NavLink to="/analysis" className={({ isActive }) => isActive ? "active" : ""}>
              <FontAwesomeIcon icon={faSearch} />
              <span>Analysis</span>
            </NavLink>
          </NavItem>
          <NavItem $collapsed={collapsed}>
          <NavLink to="/settings" className={({ isActive }) => isActive ? "active" : ""}>
              <FontAwesomeIcon icon={faCog} />
              <span>Settings</span>
            </NavLink>
          </NavItem>
          <NavItem $collapsed={collapsed}>
          <NavLink to="/help" className={({ isActive }) => isActive ? "active" : ""}>
              <FontAwesomeIcon icon={faQuestionCircle} />
              <span>Help</span>
            </NavLink>
          </NavItem>
        </NavItems>
      </div>
      <ToggleButton
        onClick={handleToggle}
        aria-label={collapsed ? "Expand Sidebar" : "Collapse Sidebar"}
      >
        <FontAwesomeIcon icon={collapsed ? faArrowRight : faArrowLeft} />
      </ToggleButton>
    </Sidebar>
  );
}
SideNav.propTypes = {
  isMobile: PropTypes.bool,
  isMobileOpen: PropTypes.bool,
  toggleMobile: PropTypes.func.isRequired,
  collapsed: PropTypes.bool,
  toggleSidebar: PropTypes.func.isRequired,
};
export default SideNav;
```

## File: src/components/common/Tooltip.jsx

```jsx
// src/components/common/Tooltip.jsx
import React from 'react';
import ReactDOM from 'react-dom';
import styled from 'styled-components';
import PropTypes from 'prop-types';
// Transient Prop: $text
const TooltipContent = styled.div`
  position: absolute;
  bottom: 125%; /* Position above the text */
  left: 50%;
  transform: translateX(-50%);
  background-color: ${({ theme }) => theme.colors.background || '#000'};
  color: ${({ theme }) => theme.colors.text || '#fff'};
  padding: 5px 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  z-index: 1001; /* Ensure it appears above other elements */
  opacity: 0.9;
  pointer-events: none;
  transition: opacity 0.3s;
`;
const TooltipArrow = styled.div`
  position: absolute;
  bottom: 115%;
  left: 50%;
  transform: translateX(-50%);
  border-width: 5px;
  border-style: solid;
  border-color: ${({ theme }) => theme.colors.background || '#000'} transparent transparent transparent;
  opacity: 0.9;
  pointer-events: none;
  z-index: 1001;
`;
const TooltipWrapper = styled.div`
  position: relative;
  display: inline-block;
  &:hover .tooltip-content {
    opacity: 1;
    visibility: visible;
  }
  &:hover .tooltip-arrow {
    opacity: 1;
    visibility: visible;
  }
`;
function Tooltip({ $text, children }) {
  const tooltip = (
    <>
      <TooltipContent className="tooltip-content">
        {$text}
      </TooltipContent>
      <TooltipArrow className="tooltip-arrow" />
    </>
  );
  return (
    <TooltipWrapper>
      {children}
      {ReactDOM.createPortal(
        tooltip,
        document.body
      )}
    </TooltipWrapper>
  );
}
Tooltip.propTypes = {
  $text: PropTypes.string.isRequired, // Updated to $text
  children: PropTypes.node.isRequired,
};
export default Tooltip;
```

## File: src/components/common/ProgressBar.jsx

```jsx
// frontend/src/components/common/ProgressBar.jsx
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
const ProgressBarContainer = styled.div`
  margin-top: 20px;
`;
const ProgressWrapper = styled.div`
  width: 100%;
  background-color: #e0e0e0;
  padding: 3px;
  border-radius: 6px;
  overflow: hidden;
`;
const ProgressBarStyled = styled.div`
  height: 22px;
  background: linear-gradient(90deg, ${({ theme }) => theme.colors.primary}, #00c6ff);
  border-radius: 3px;
  width: ${({ $progress }) => `${$progress}%`};
  transition: width 0.3s ease-in-out;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 500;
`;
function ProgressBar({ progress }) {
  if (progress === 0) return null;
  return (
    <ProgressBarContainer>
      <ProgressWrapper>
        <ProgressBarStyled
          $progress={progress}
          role="progressbar"
          aria-valuenow={progress}
          aria-valuemin="0"
          aria-valuemax="100"
        >
          {progress}%
        </ProgressBarStyled>
      </ProgressWrapper>
    </ProgressBarContainer>
  );
}
ProgressBar.propTypes = {
  progress: PropTypes.number.isRequired,
};
export default ProgressBar;
```

## File: src/components/common/FileDashboard.jsx

```jsx
// src/components/common/FileDashboard.jsx
import React, { useState, useRef } from 'react';
import MediaPlayer from './MediaPlayer';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import Tooltip from './Tooltip'; // Import Tooltip component
import { Link } from 'react-router-dom'; // If using Link
// Styled Components
const DashboardContainer = styled.div`
  margin-top: 30px;
`;
const FileGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 20px;
  @media (max-width: 1199px) {
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  }
  @media (max-width: 767px) {
    grid-template-columns: 1fr;
    gap: 15px;
  }
`;
const FileCard = styled.div`
  background-color: ${({ theme }) => theme.colors.neutral};
  padding: 20px;
  border-radius: 10px;
  box-sizing: border-box;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  text-align: center;
  transition: transform 0.2s ease, box-shadow 0.3s ease;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  justify-content: center;
  height: 150px; /* Fixed height for consistency */
  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
  }
  p {
    margin-bottom: 10px;
    color: ${({ theme }) => theme.colors.text};
    font-size: 16px;
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  @media (max-width: 767px) {
    padding: 15px;
    height: auto;
    p {
      font-size: 14px;
    }
  }
`;
function FileDashboard({ uploadedFiles }) {
  const [currentIndex, setCurrentIndex] = useState(null);
  const triggerRef = useRef(null);
  const selectFile = (index, event) => {
    triggerRef.current = event.currentTarget;
    setCurrentIndex(index);
  };
  const closeMediaPlayer = () => {
    setCurrentIndex(null);
    if (triggerRef.current) {
      triggerRef.current.focus();
    }
  };
  const handleNextTrack = () => {
    setCurrentIndex((prevIndex) => {
      if (prevIndex === null) return 0;
      return (prevIndex + 1) % uploadedFiles.length;
    });
  };
  const handlePrevTrack = () => {
    setCurrentIndex((prevIndex) => {
      if (prevIndex === null) return uploadedFiles.length - 1;
      return (prevIndex - 1 + uploadedFiles.length) % uploadedFiles.length;
    });
  };
  return (
    <DashboardContainer>
      <h2>Uploaded Files</h2>
      <FileGrid>
        {uploadedFiles.length > 0 ? (
          uploadedFiles.map((file, index) => (
            <FileCard 
              key={index} 
              onClick={(e) => selectFile(index, e)} 
              tabIndex="0" 
              onKeyPress={(e) => {
                if (e.key === 'Enter') selectFile(index, e);
              }}
              aria-label={`Play ${file.filename}`}
            >
              <Tooltip $text={file.filename}> {/* Corrected to use $text */}
                <p>{file.filename}</p>
              </Tooltip>
              <p>{(file.size / (1024 * 1024)).toFixed(2)} MB</p>
              {/* Add more details if necessary */}
            </FileCard>
          ))
        ) : (
          <p>No files uploaded yet.</p>
        )}
      </FileGrid>
      {currentIndex !== null && (
        <MediaPlayer
          fileUrl={
            uploadedFiles[currentIndex].path.startsWith('/static/uploads') 
              ? `${window.location.origin}${uploadedFiles[currentIndex].path}` 
              : uploadedFiles[currentIndex].path
          }
          fileName={uploadedFiles[currentIndex].filename}
          fileType={uploadedFiles[currentIndex].type}
          fileSize={uploadedFiles[currentIndex].size}
          duration={uploadedFiles[currentIndex].duration}
          onClose={closeMediaPlayer}
          onNextTrack={handleNextTrack}
          onPrevTrack={handlePrevTrack}
        />
      )}
    </DashboardContainer>
  );
}
FileDashboard.propTypes = {
  uploadedFiles: PropTypes.arrayOf(
    PropTypes.shape({
      filename: PropTypes.string.isRequired,
      path: PropTypes.string.isRequired,
      size: PropTypes.number.isRequired,
      type: PropTypes.string.isRequired,
      duration: PropTypes.string,
    })
  ).isRequired,
};
export default FileDashboard;
```

## File: src/components/common/Breadcrumbs.jsx

```jsx
// src/components/common/Breadcrumbs.jsx
import React from "react";
import { Link, useLocation } from "react-router-dom";
import styled from "styled-components";
import PropTypes from "prop-types";
// Styled Components
const BreadcrumbContainer = styled.nav`
  padding: 10px 20px;
  background-color: #ecf0f1;
  font-size: 0.9em;
`;
const BreadcrumbList = styled.ol`
  list-style: none;
  display: flex;
  flex-wrap: wrap;
  margin: 0;
  padding: 0;
`;
const BreadcrumbItem = styled.li`
  margin-right: 5px;
  &:after {
    content: ">";
    margin-left: 5px;
  }
  &:last-child:after {
    content: "";
  }
  a {
    text-decoration: none;
    color: #3498db;
    &:hover {
      text-decoration: underline;
    }
  }
`;
// Component
function Breadcrumbs() {
  const location = useLocation();
  const pathnames = location.pathname.split("/").filter((x) => x);
  return (
    <BreadcrumbContainer aria-label="breadcrumb">
      <BreadcrumbList>
        <BreadcrumbItem>
          <Link to="/dashboard">Dashboard</Link>
        </BreadcrumbItem>
        {pathnames.map((value, index) => {
          const to = `/${pathnames.slice(0, index + 1).join("/")}`;
          const isLast = index === pathnames.length - 1;
          const label = value.replace(/-/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
          return (
            <BreadcrumbItem key={to}>
              {isLast ? <span>{label}</span> : <Link to={to}>{label}</Link>}
            </BreadcrumbItem>
          );
        })}
      </BreadcrumbList>
    </BreadcrumbContainer>
  );
}
Breadcrumbs.propTypes = {
};
export default Breadcrumbs;
```

## File: src/components/pages/Help.jsx

```jsx
// src/components/pages/Help.jsx
import React from 'react';
import styled from 'styled-components';
const HelpContainer = styled.div`
  padding: 20px;
`;
function Help() {
  return (
    <HelpContainer>
      <h1>Help</h1>
      <p>This section will provide help and support information.</p>
    </HelpContainer>
  );
}
export default Help;
```

## File: src/components/pages/Upload.jsx

```jsx
import React, { useState } from 'react';
import styled from 'styled-components';
import FileUploader from '../common/FileUploader';
import Notification from '../common/Notification';
const UploadContainer = styled.div`
  padding: 20px;
`;
function Upload() {
  const [notification, setNotification] = useState({ message: '', type: 'success' });
  const [uploadedFiles, setUploadedFiles] = useState([]);
  return (
    <UploadContainer>
      <h1>Upload Files</h1>
      {notification.message && (
        <Notification 
          message={notification.message} 
          type={notification.type} 
          onClose={() => setNotification({ message: '', type: 'success' })} 
        />
      )}
      <FileUploader 
        setUploadedFiles={setUploadedFiles} 
        setNotification={setNotification} 
      />
      {/* Optionally, display uploaded files after upload */}
      {uploadedFiles.length > 0 && (
        <div>
          <h2>Uploaded Files:</h2>
          <ul>
            {uploadedFiles.map((file, index) => (
              <li key={index}>{file.filename}</li>
            ))}
          </ul>
        </div>
      )}
    </UploadContainer>
  );
}
export default Upload;
```

## File: src/components/pages/Dashboard.jsx

```jsx
import React, { useEffect, useState } from 'react';
import styled from 'styled-components';
import FileDashboard from '../common/FileDashboard';
import Notification from '../common/Notification';
const DashboardContainer = styled.div`
  padding: 20px;
`;
function Dashboard() {
  const [uploadedFiles, setUploadedFiles] = useState([]);
  const [notification, setNotification] = useState({ message: '', type: 'success' });
  useEffect(() => {
    fetch('/api/file_history')
      .then((response) => response.json())
      .then((data) => {
        if (data.files) {
          setUploadedFiles(data.files);
        }
      })
      .catch((error) => {
        console.error('Error fetching file history:', error);
        setNotification({ message: 'Failed to fetch file history.', type: 'error' });
      });
  }, []);
  return (
    <DashboardContainer>
      <h1>Dashboard</h1>
      {notification.message && (
        <Notification 
          message={notification.message} 
          type={notification.type} 
          onClose={() => setNotification({ message: '', type: 'success' })} 
        />
      )}
      <FileDashboard uploadedFiles={uploadedFiles} />
    </DashboardContainer>
  );
}
export default Dashboard;
```

## File: src/components/pages/Settings.jsx

```jsx
import React, { useState } from 'react';
import styled from 'styled-components';
import Notification from '../common/Notification';
import Button from '../common/Button';
const SettingsContainer = styled.div`
  padding: 20px;
`;
const SettingsForm = styled.form`
  display: flex;
  flex-direction: column;
  gap: 15px;
`;
const Label = styled.label`
  font-size: ${({ theme }) => theme.fontSizes.body};
  color: ${({ theme }) => theme.colors.text};
`;
const Input = styled.input`
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: ${({ theme }) => theme.fontSizes.body};
  font-family: ${({ theme }) => theme.fonts.primary};
  &:focus {
    border-color: ${({ theme }) => theme.colors.primary};
    outline: none;
    box-shadow: 0 0 0 2px rgba(30, 144, 255, 0.2);
  }
`;
function Settings() {
  const [notification, setNotification] = useState({ message: '', type: 'success' });
  const [settings, setSettings] = useState({
    username: '',
    email: '',
  });
  const handleChange = (e) => {
    setSettings({
      ...settings,
      [e.target.name]: e.target.value,
    });
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    // Implement settings update logic here
    setNotification({ message: 'Settings updated successfully!', type: 'success' });
  };
  return (
    <SettingsContainer>
      <h1>Settings</h1>
      {notification.message && (
        <Notification 
          message={notification.message} 
          type={notification.type} 
          onClose={() => setNotification({ message: '', type: 'success' })} 
        />
      )}
      <SettingsForm onSubmit={handleSubmit}>
        <div>
          <Label htmlFor="username">Username</Label>
          <Input 
            type="text" 
            id="username" 
            name="username" 
            value={settings.username} 
            onChange={handleChange} 
            required 
          />
        </div>
        <div>
          <Label htmlFor="email">Email</Label>
          <Input 
            type="email" 
            id="email" 
            name="email" 
            value={settings.email} 
            onChange={handleChange} 
            required 
          />
        </div>
        <Button variant="primary" type="submit">
          Save Settings
        </Button>
      </SettingsForm>
    </SettingsContainer>
  );
}
export default Settings;
```

## File: src/components/pages/Library.jsx

```jsx
// src/components/pages/Library.jsx
import React from 'react';
import styled from 'styled-components';
import FileDashboard from '../common/FileDashboard';
const LibraryContainer = styled.div`
  padding: 20px;
`;
function Library() {
  // Dummy data for demonstration
  const dummyFiles = [
    {
      filename: 'SampleAudio1.mp3',
      path: '/static/uploads/SampleAudio1.mp3',
      size: 10485760, // 10 MB
      type: 'audio/mpeg',
      duration: '03:45',
    },
    {
      filename: 'SampleVideo1.mp4',
      path: '/static/uploads/SampleVideo1.mp4',
      size: 52428800, // 50 MB
      type: 'video/mp4',
      duration: '10:20',
    },
  ];
  return (
    <LibraryContainer>
      <h1>Library</h1>
      <FileDashboard uploadedFiles={dummyFiles} />
    </LibraryContainer>
  );
}
export default Library;
```

