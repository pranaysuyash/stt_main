Directory Structure:
```
├── common/
│   ├── AudioPlayer.jsx
│   ├── Button.jsx
│   ├── ErrorBoundary.jsx
│   ├── FileDashboard.jsx
│   ├── FileUploader.jsx
│   ├── MediaPlayer.jsx
│   ├── Messages.jsx
│   ├── Notification.jsx
│   ├── PreviewSection.jsx
│   ├── ProgressBar.jsx
│   ├── Tooltip.jsx
│   ├── VideoPlayer.jsx
│   └── WaveformViewer.jsx
└── pages/
    ├── Dashboard.jsx
    ├── Settings.jsx
    └── Upload.jsx
```

## File: common/VideoPlayer.jsx

```jsx
// src/components/common/VideoPlayer.jsx
import React, { useRef, useState } from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';

// Styled Components
const VideoPlayerContainer = styled.div`
  margin-top: 30px;
  padding: 20px;
  background-color: ${({ theme }) => theme.colors.background};
  border-radius: 10px;
  text-align: center;
  position: relative;
`;

const Video = styled.video`
  width: 100%;
  max-width: 800px;
  border-radius: 5px;
`;

const Controls = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 15px;

  button {
    margin: 0 10px;
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background-color: ${({ theme }) => theme.colors.primary};
    color: white;
    transition: background-color 0.2s ease;

    &:hover {
      background-color: ${({ theme }) => theme.colors.secondary};
    }
  }

  button.loop-active {
    background-color: #e74c3c; /* Red color to indicate active loop */
  }
`;

const CloseButton = styled.button`
  margin-top: 15px;
  background-color: ${({ theme }) => theme.colors.error};
  border: none;
  color: white;
  padding: 8px 15px;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s ease;

  &:hover {
    background-color: #c0392b;
  }
`;

// VideoPlayer Component
function VideoPlayer({ 
  fileUrl, 
  fileName, 
  fileType, 
  fileSize, 
  duration = '', // Default value
  onClose 
}) {
  const videoRef = useRef(null);
  const [isLooping, setIsLooping] = useState(false);

  const handleError = (e) => {
    console.error('Video playback error:', e);
    onClose(); // Close the media player on error
  };

  const handleFullscreen = () => {
    if (videoRef.current) {
      if (videoRef.current.requestFullscreen) {
        videoRef.current.requestFullscreen();
      } else if (videoRef.current.webkitRequestFullscreen) { /* Safari */
        videoRef.current.webkitRequestFullscreen();
      } else if (videoRef.current.msRequestFullscreen) { /* IE11 */
        videoRef.current.msRequestFullscreen();
      }
    }
  };

  const toggleLoop = () => {
    setIsLooping(!isLooping);
    if (videoRef.current) {
      videoRef.current.loop = !isLooping;
    }
  };

  return (
    <VideoPlayerContainer>
      <h3>Now Playing: {fileName}</h3>
      {fileSize && (
        <p>File Size: {(fileSize / (1024 * 1024)).toFixed(2)} MB</p>
      )}
      {duration && <p>Duration: {duration}</p>}

      <Video
        ref={videoRef}
        src={fileUrl}
        controls
        onError={handleError}
        aria-label={`Video player for ${fileName}`}
      >
        Your browser does not support the video tag.
      </Video>

      <Controls>
        <button 
          onClick={handleFullscreen} 
          aria-label="Enter Fullscreen Mode"
        >
          Fullscreen
        </button>
        <button 
          onClick={toggleLoop} 
          aria-label={isLooping ? 'Disable Loop' : 'Enable Loop'}
          className={isLooping ? 'loop-active' : ''}
        >
          {isLooping ? 'Looping' : 'Loop'}
        </button>
      </Controls>

      <CloseButton onClick={onClose} aria-label="Close Video Player">Close</CloseButton>
    </VideoPlayerContainer>
  );
}

VideoPlayer.propTypes = {
  fileUrl: PropTypes.string.isRequired,
  fileName: PropTypes.string.isRequired,
  fileType: PropTypes.string.isRequired,
  fileSize: PropTypes.number.isRequired,
  duration: PropTypes.string,
  onClose: PropTypes.func.isRequired,
};

export default VideoPlayer;

```

## File: common/PreviewSection.jsx

```jsx
// frontend/src/components/common/PreviewSection.jsx
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';

const PreviewContainer = styled.div`
  margin-top: 20px;
`;

const PreviewItem = styled.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: ${({ theme }) => theme.colors.background};
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 5px;
  margin-bottom: 10px;
`;

const FileInfo = styled.div`
  display: flex;
  flex-direction: column;
`;

const RemoveButton = styled.button`
  background-color: ${({ theme }) => theme.colors.error};
  border: none;
  color: white;
  padding: 5px 10px;
  border-radius: 3px;
  cursor: pointer;

  &:hover {
    background-color: #c0392b;
  }
`;

function PreviewSection({ selectedFiles, removeFile }) {
  return (
    <PreviewContainer>
      <h3>Selected Files</h3>
      {selectedFiles.map((file, index) => (
        <PreviewItem key={index}>
          <FileInfo>
            <span><strong>{file.name}</strong></span>
            <span>{(file.size / (1024 * 1024)).toFixed(2)} MB</span>
          </FileInfo>
          <RemoveButton onClick={() => removeFile(index)}>Remove</RemoveButton>
        </PreviewItem>
      ))}
    </PreviewContainer>
  );
}

PreviewSection.propTypes = {
  selectedFiles: PropTypes.arrayOf(PropTypes.object).isRequired,
  removeFile: PropTypes.func.isRequired,
};

export default PreviewSection;

```

## File: common/FileUploader.jsx

```jsx
// src/components/common/FileUploader.jsx
import React, { useState, useRef } from 'react';
import styled from 'styled-components';
import PreviewSection from './PreviewSection';
import ProgressBar from './ProgressBar';
import Button from './Button'; // Ensure this component exists
import { faUpload } from '@fortawesome/free-solid-svg-icons';
import PropTypes from 'prop-types';
import { ErrorMessage } from './Messages'; // Import only ErrorMessage

const UploadSection = styled.div`
  margin-top: 20px;
`;

const OverwritePrompt = styled.div`
  background-color: ${({ theme }) => theme.colors.background};
  padding: 15px;
  border: 1px solid ${({ theme }) => theme.colors.warning};
  border-radius: 5px;
  margin-top: 20px;
  
  p {
    margin-bottom: 15px;
    color: ${({ theme }) => theme.colors.text};
    font-size: ${({ theme }) => theme.fontSizes.body};
  }
`;

// New styled component for button container
const OverwriteButtons = styled.div`
  display: flex;
  justify-content: center;
  gap: 10px; /* Space between buttons */
  
  button {
    flex: 1; /* Ensure both buttons take equal space */
  }
`;

const DropZone = styled.div`
  border: 2px dashed #bbb;
  border-radius: 12px;
  background-color: ${({ theme }) => theme.colors.neutral};
  padding: 40px;
  text-align: center;
  transition: background-color 0.3s ease, box-shadow 0.2s ease;
  cursor: pointer;

  &:hover, &.drag-over {
    background-color: ${({ theme }) => theme.colors.background};
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
  }

  i {
    font-size: 50px;
    color: ${({ theme }) => theme.colors.primary};
    margin-bottom: 10px;
  }

  p {
    color: ${({ theme }) => theme.colors.text};
    font-size: ${({ theme }) => theme.fontSizes.body};
  }
`;

function FileUploader({ setUploadedFiles, setNotification }) {
  const [selectedFiles, setSelectedFiles] = useState([]);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [errorMessages, setErrorMessages] = useState([]); // Changed to array
  const [isUploading, setIsUploading] = useState(false);
  const [overwritePrompt, setOverwritePrompt] = useState(false);
  const [overwriteFile, setOverwriteFile] = useState(null);
  const fileInputRef = useRef(null);

  // Handle file selection from input or drag-and-drop
  const handleFiles = (event) => {
    event.preventDefault();
    event.stopPropagation();

    setErrorMessages([]);
    setNotification({ message: '', type: '' });

    let files;
    if (event.type === 'drop') {
      files = event.dataTransfer.files;
    } else {
      files = event.target.files;
    }

    if (files.length === 0) {
      setErrorMessages(['No files selected.']);
      return;
    }

    const allowedMimeTypes = [
      'audio/mpeg',
      'audio/wav',
      'video/mp4',
      'video/x-msvideo',
      'video/quicktime' // Include quicktime to allow .mov files
    ];

    const invalidTypeFiles = Array.from(files).filter(
      file => !allowedMimeTypes.includes(file.type)
    );

    const oversizedFiles = Array.from(files).filter(
      file => file.size > 200 * 1024 * 1024 // 200MB
    );

    let newErrorMessages = [];

    if (invalidTypeFiles.length > 0) {
      newErrorMessages.push(`Unsupported file types: ${invalidTypeFiles.map(f => f.name).join(', ')}`);
    }

    if (oversizedFiles.length > 0) {
      newErrorMessages.push(`Files too large (max 200MB): ${oversizedFiles.map(f => f.name).join(', ')}`);
    }

    if (newErrorMessages.length > 0) {
      setErrorMessages(newErrorMessages);
      return;
    }

    setSelectedFiles((prevFiles) => [...prevFiles, ...Array.from(files)]);
  };

  // Prevent default behavior in drag events
  const handleDragOver = (event) => {
    event.preventDefault();
    event.stopPropagation();
  };

  const handleDrop = (event) => {
    event.preventDefault();
    event.stopPropagation();
    handleFiles(event);
  };

  // Check if the file already exists
  const checkFileExists = async (fileName) => {
    try {
      const response = await fetch(`/api/file_exists?filename=${encodeURIComponent(fileName)}`);
      const data = await response.json();
      return data.exists;
    } catch (error) {
      console.error('Error checking file existence:', error);
      return false;
    }
  };

  // Handle file upload to the server
  const uploadFiles = async () => {
    if (selectedFiles.length === 0) {
      setErrorMessages(['Please select files to upload.']);
      return;
    }

    const fileExists = await checkFileExists(selectedFiles[0].name);

    if (fileExists) {
      setOverwritePrompt(true);
      setOverwriteFile(selectedFiles[0].name);
      return;
    }

    handleUpload(selectedFiles);
  };

  const handleUpload = async(files) => {
    setIsUploading(true);
    setUploadProgress(0);
    setErrorMessages([]);

    const formData = new FormData();
    files.forEach((file) => {
      formData.append('file', file);
    });

  //   const xhr = new XMLHttpRequest();

  //   xhr.upload.addEventListener('progress', (event) => {
  //     if (event.lengthComputable) {
  //       const percentComplete = Math.round((event.loaded / event.total) * 100);
  //       setUploadProgress(percentComplete);
  //     }
  //   });

  //   xhr.onreadystatechange = () => {
  //     if (xhr.readyState === 4) {
  //       setIsUploading(false);
  //       setUploadProgress(0);

  //       if (xhr.status === 200 || xhr.status === 207) {
  //         const response = JSON.parse(xhr.responseText);
  //         if (response.uploaded_files) {
  //           setNotification({ message: 'Files uploaded successfully!', type: 'success' });
  //         }
  //         if (response.errors) {
  //           const newErrors = response.errors.map(err => `${err.filename}: ${err.error}`);
  //           setErrorMessages(newErrors);
  //         }
  //         setSelectedFiles([]);
  //         fetch('/api/file_history')
  //           .then((res) => res.json())
  //           .then((data) => {
  //             if (data.files) {
  //               setUploadedFiles(data.files);
  //             }
  //           })
  //           .catch((error) => console.error('Error fetching files:', error));
  //       } else if (xhr.status === 413) {
  //         const response = JSON.parse(xhr.responseText);
  //         setErrorMessages([`${response.error}: ${response.message}`]);
  //       } else {
  //         setNotification({ message: 'Error uploading files. Please try again.', type: 'error' });
  //         console.error('Error uploading files:', xhr.responseText);
  //       }
  //     }
  //   };

  //   xhr.open('POST', '/upload');
  //   xhr.send(formData);
  // };

  try {
    const response = await fetch('/upload', {
      method: 'POST',
      body: formData,
    });

    // Calculate upload progress manually since fetch doesn't provide progress updates
    // For more advanced progress tracking, consider using Axios

    const data = await response.json();

    if (response.ok || response.status === 207) {
      if (data.uploaded_files) {
        setNotification({ message: 'Files uploaded successfully!', type: 'success' });
      }
      if (data.errors) {
        const newErrors = data.errors.map(err => `${err.filename}: ${err.error}`);
        setErrorMessages(newErrors);
      }
      setSelectedFiles([]);
      const historyResponse = await fetch('/api/file_history');
      const historyData = await historyResponse.json();
      if (historyData.files) {
        setUploadedFiles(historyData.files);
      }
    } else if (response.status === 413) {
      const errorData = await response.json();
      setErrorMessages([`${errorData.error}: ${errorData.message}`]);
    } else {
      setNotification({ message: 'Error uploading files. Please try again.', type: 'error' });
      console.error('Error uploading files:', data);
    }
  } catch (error) {
    setNotification({ message: 'Network error during file upload.', type: 'error' });
    console.error('Network error:', error);
  } finally {
    setIsUploading(false);
    setUploadProgress(0);
  }
};

  // Remove selected files
  const removeFile = (index) => {
    setSelectedFiles((prevFiles) => prevFiles.filter((_, i) => i !== index));
  };

  return (
    <UploadSection>
      {/* Drop zone for files */}
      <DropZone
        role="button"
        aria-label="File Upload Zone"
        onDragOver={handleDragOver}
        onDragEnter={handleDragOver}
        onDragLeave={handleDragOver}
        onDrop={handleDrop}
        onClick={() => fileInputRef.current.click()}
        className={isUploading ? 'disabled' : ''}
      >
        <i className="fas fa-cloud-upload-alt"></i>
        <p>Click here or drag and drop audio or video files (max 200MB)</p>
        <input
          type="file"
          id="file-input"
          accept="audio/*,video/*"
          multiple
          style={{ display: 'none' }}
          onChange={handleFiles}
          ref={fileInputRef}
        />
      </DropZone>

      {/* Display selected files */}
      {selectedFiles.length > 0 && (
        <>
          <PreviewSection
            selectedFiles={selectedFiles}
            removeFile={removeFile}
          />
          <Button
            variant="primary"
            icon={faUpload}
            onClick={uploadFiles}
            disabled={isUploading}
            aria-label={isUploading ? 'Uploading files' : 'Upload Files'}
          >
            {isUploading ? 'Uploading...' : 'Upload Files'}
          </Button>
          <ProgressBar progress={uploadProgress} />
        </>
      )}

      {/* Display error messages */}
      {errorMessages.length > 0 && (
        <ErrorMessage>
          {errorMessages.map((msg, index) => (
            <p key={index}>{msg}</p>
          ))}
        </ErrorMessage>
      )}

      {/* Overwrite Prompt */}
      {overwritePrompt && (
        <OverwritePrompt>
          <p>File "{overwriteFile}" already exists. Do you want to overwrite it?</p>
          <OverwriteButtons>
            <Button
              variant="secondary"
              customColor="#2ecc71" /* Complimentary green for "Yes" button */
              onClick={() => {
                handleUpload(selectedFiles);
                setOverwritePrompt(false);
              }}
              aria-label="Yes, overwrite the existing file"
            >
              Yes
            </Button>
            <Button
              variant="secondary" /* Changed from 'tertiary' to 'secondary' for consistent styling */
              customColor="#e74c3c" /* Custom red color for "No" button */
              onClick={() => setOverwritePrompt(false)}
              aria-label="No, cancel the upload"
            >
              No
            </Button>
          </OverwriteButtons>
        </OverwritePrompt>
      )}
    </UploadSection>
  );
}

FileUploader.propTypes = {
  setUploadedFiles: PropTypes.func.isRequired,
  setNotification: PropTypes.func.isRequired,
};

export default FileUploader;

```

## File: common/ErrorBoundary.jsx

```jsx
// src/components/common/ErrorBoundary.jsx
import React from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';

const FallbackContainer = styled.div`
  padding: 20px;
  background-color: ${({ theme }) => theme.colors.error};
  color: white;
  border-radius: 5px;
  text-align: center;
`;

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error Boundary Caught an error:', error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <FallbackContainer>Something went wrong.</FallbackContainer>;
    }

    return this.props.children; 
  }
}

ErrorBoundary.propTypes = {
  children: PropTypes.node.isRequired,
};

export default ErrorBoundary;

```

## File: common/MediaPlayer.jsx

```jsx
// src/components/common/MediaPlayer.jsx
import React, { useEffect, useRef, useState } from 'react';
import AudioPlayer from './AudioPlayer';
import VideoPlayer from './VideoPlayer';
import styled, { keyframes } from 'styled-components';
import PropTypes from 'prop-types';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faForward, faBackward, faTimes } from '@fortawesome/free-solid-svg-icons';
import { faPlay, faPause, faStop, faRedo, faVolumeUp, faVolumeMute } from '@fortawesome/free-solid-svg-icons';
import FocusTrap from 'focus-trap-react';

// Keyframes for fade-in animation
const fadeIn = keyframes`
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
`;

// Styled Components for Modal
const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 2000; /* Above other elements */
  animation: ${fadeIn} 0.3s ease-out;
`;

const ModalContent = styled.div`
  background-color: ${({ theme }) => theme.colors.background};
  padding: 20px;
  border-radius: 10px;
  width: 90%;
  max-width: 800px;
  position: relative;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  max-height: 90vh;
  overflow-y: auto;

  @media (max-width: 767px) {
    padding: 15px;
    width: 95%;
    max-width: 100%;
    border-radius: 0;
    height: 100vh;
    max-height: 100vh;
  }
`;

const CloseIcon = styled(FontAwesomeIcon)`
  position: absolute;
  top: 15px;
  right: 15px;
  cursor: pointer;
  color: ${({ theme }) => theme.colors.error};
  font-size: 1.5rem;

  &:hover {
    color: #c0392b;
  }

  @media (max-width: 767px) {
    top: 10px;
    right: 10px;
    font-size: 1.2rem;
  }
`;

const NavigationControls = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 20px;

  button {
    margin: 0 15px;
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background-color: ${({ theme }) => theme.colors.primary};
    color: white;
    transition: background-color 0.2s ease;

    &:hover {
      background-color: ${({ theme }) => theme.colors.secondary};
    }
  }

  @media (max-width: 767px) {
    button {
      padding: 6px 10px;
      margin: 0 10px;
    }
  }
`;

// MediaPlayer Component as Modal
function MediaPlayer({ 
  fileUrl, 
  fileName, 
  fileType, 
  fileSize, 
  duration = '', // Default value
  onClose, 
  onNextTrack, 
  onPrevTrack 
}) {
  const closeButtonRef = useRef(null);

  useEffect(() => {
    if (closeButtonRef.current) {
      closeButtonRef.current.focus();
    }
  }, []);
  return (
    <ModalOverlay onClick={onClose} aria-modal="true" role="dialog">
      <FocusTrap>
        <ModalContent onClick={(e) => e.stopPropagation()}>
          <CloseIcon icon={faTimes} onClick={onClose} aria-label="Close Media Player" ref={closeButtonRef} />
          {fileType && fileType.startsWith('audio/') ? (
            <AudioPlayer
              fileUrl={fileUrl}
              fileName={fileName}
              fileType={fileType}
              fileSize={fileSize}
              duration={duration}
              onClose={onClose}
            />
          ) : (
            <VideoPlayer
              fileUrl={fileUrl}
              fileName={fileName}
              fileType={fileType}
              fileSize={fileSize}
              duration={duration}
              onClose={onClose}
            />
          )}

          {/* Navigation Controls */}
          <NavigationControls>
            <button onClick={onPrevTrack} aria-label="Previous Track">
              <FontAwesomeIcon icon={faBackward} /> Previous
            </button>
            <button onClick={onNextTrack} aria-label="Next Track">
              Next <FontAwesomeIcon icon={faForward} />
            </button>
          </NavigationControls>
        </ModalContent>
      </FocusTrap>
    </ModalOverlay>
  );
}

MediaPlayer.propTypes = {
  fileUrl: PropTypes.string.isRequired,
  fileName: PropTypes.string.isRequired,
  fileType: PropTypes.string.isRequired,
  fileSize: PropTypes.number.isRequired,
  duration: PropTypes.string,
  onClose: PropTypes.func.isRequired,
  onNextTrack: PropTypes.func.isRequired,
  onPrevTrack: PropTypes.func.isRequired,
};

export default MediaPlayer;

```

## File: common/Button.jsx

```jsx
// frontend/src/components/common/Button.jsx
import React from 'react';
import PropTypes from 'prop-types';
import styled from 'styled-components';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';

const ButtonStyled = styled.button`
  padding: 10px 20px;
  border: none;
  border-radius: 4px;
  font-size: ${({ theme }) => theme.fontSizes.body};
  cursor: pointer;
  background-color: ${({ $variant,$customColor, theme }) =>
    $customColor ? $customColor :
    $variant === 'primary' ? theme.colors.primary :
    $variant === 'secondary' ? theme.colors.secondary :
    theme.colors.neutral};
  color: ${({ $variant, $customColor }) =>
    $variant === 'tertiary' ? theme.colors.text : '#fff'};
  
  display: flex;
  align-items: center;
    justify-content: center;

  
  &:hover {
    opacity: 0.9;
  }

  &:disabled {
    background-color: #ccc;
    cursor: not-allowed;
  }

  /* Focus Styles */
  &:focus {
    outline: 2px solid ${({ theme }) => theme.colors.primary};
    outline-offset: 2px;
  }
`;

const Button = ({ 
  variant = 'primary', 
  children, 
  onClick = () => {}, 
  disabled = false, 
  icon = null, 
  type = 'button',
  customColor = null // New prop for custom background color
}) => (
  <ButtonStyled variant={variant} onClick={onClick} disabled={disabled} type={type} customColor={customColor} aria-label={typeof children === "string" ? children : undefined}>
    {icon && <FontAwesomeIcon icon={icon} style={{ marginRight: '8px' }} />}
    {children}
  </ButtonStyled>
);

Button.propTypes = {
  variant: PropTypes.oneOf(['primary', 'secondary', 'tertiary']),
  children: PropTypes.node.isRequired,
  onClick: PropTypes.func,
  disabled: PropTypes.bool,
  icon: PropTypes.object, // FontAwesomeIcon expects an icon object
  type: PropTypes.oneOf(['button', 'submit', 'reset']),
  customColor: PropTypes.string, // New prop type
};

export default Button;

```

## File: common/Notification.jsx

```jsx
// frontend/src/components/common/Notification.jsx
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import { faTimes } from '@fortawesome/free-solid-svg-icons';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';

const NotificationContainer = styled.div`
  background-color: ${({ $type, theme }) => 
    $type === 'success' ? theme.colors.success :
    $type === 'error' ? theme.colors.error :
    theme.colors.warning};
  color: white;
  padding: 15px 20px;
  border-radius: 5px;
  position: relative;
  margin-top: 20px;
`;

const CloseButton = styled.button`
  position: absolute;
  top: 10px;
  right: 10px;
  background: transparent;
  border: none;
  color: white;
  cursor: pointer;
`;

function Notification({ message, type = 'success', onClose }) {
  return (
    <NotificationContainer $type={type} role="alert" aria-live="assertive">
      <span>{message}</span>
      <CloseButton onClick={onClose} aria-label="Close Notification">
        <FontAwesomeIcon icon={faTimes} />
      </CloseButton>
    </NotificationContainer>
  );
}

Notification.propTypes = {
  message: PropTypes.string.isRequired,
  type: PropTypes.oneOf(['success', 'error', 'warning']),
  onClose: PropTypes.func.isRequired,
};

export default Notification;

```

## File: common/WaveformViewer.jsx

```jsx
// src/components/common/WaveformViewer.jsx
import React, { useEffect, useRef } from 'react';
import WaveSurfer from 'wavesurfer.js';
import styled from 'styled-components';

const WaveformViewerContainer = styled.div`
  margin-top: 20px;
  background-color: ${({ theme }) => theme.colors.neutral};
  padding: 20px;
  border-radius: 10px;
`;

const Waveform = styled.div`
  width: 100%;
  height: 150px;
`;

function WaveformViewer({ fileUrl }) {
  const waveformRef = useRef(null);
  const wavesurferRef = useRef(null);
  const resizeTimeout = useRef(null);

  useEffect(() => {
    if (waveformRef.current && fileUrl) {
      wavesurferRef.current = WaveSurfer.create({
        container: waveformRef.current,
        waveColor: '#D9DCFF',
        progressColor: '#4353FF',
        cursorColor: '#4353FF',
        responsive: true,
        height: 150,
        barWidth: 2,
        barRadius: 3,
        backend: 'WebAudio',
      });

      wavesurferRef.current.load(fileUrl);

      // Handle errors
      wavesurferRef.current.on('error', (error) => {
        console.error('WaveSurfer error:', error);
      });

      // Debounced resize handler
      const handleResize = () => {
        clearTimeout(resizeTimeout.current);
        resizeTimeout.current = setTimeout(() => {
          if (wavesurferRef.current) {
            wavesurferRef.current.empty();
            wavesurferRef.current.drawBuffer();
          }
        }, 300);
      };

      window.addEventListener('resize', handleResize);

      return () => {
        window.removeEventListener('resize', handleResize);
        clearTimeout(resizeTimeout.current);
        if (wavesurferRef.current) {
          wavesurferRef.current.destroy();
        }
      };
    }
  }, [fileUrl]);

  return (
    <WaveformViewerContainer>
      <h3>Waveform Preview</h3>
      <Waveform id="waveform-viewer" ref={waveformRef} aria-label="Audio waveform visualization"></Waveform>
    </WaveformViewerContainer>
  );
}

WaveformViewer.propTypes = {
  fileUrl: PropTypes.string.isRequired,
};

export default WaveformViewer;

```

## File: common/Messages.jsx

```jsx
// frontend/src/components/common/Messages.jsx
import styled from 'styled-components';
import PropTypes from 'prop-types';

// Error Message Component
export const ErrorMessage = styled.div.attrs({
  role: 'alert',
  'aria-live': 'assertive',
})`
  color: ${({ theme }) => theme.colors.error};
  background-color: #ffe6e6;
  padding: 10px 15px;
  border: 1px solid ${({ theme }) => theme.colors.error};
  border-radius: 5px;
  margin-top: 10px;
`;

ErrorMessage.propTypes = {
  children: PropTypes.node.isRequired,
};

```

## File: common/AudioPlayer.jsx

```jsx
// src/components/common/AudioPlayer.jsx
import React, { useEffect, useRef, useState } from 'react';
import WaveSurfer from 'wavesurfer.js';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { faPlay, faPause, faStop, faRedo, faVolumeUp, faVolumeMute } from '@fortawesome/free-solid-svg-icons';

// Styled Components
const AudioPlayerContainer = styled.div`
  margin-top: 20px;
  text-align: center;
  background-color: ${({ theme }) => theme.colors.background};
  padding: 20px;
  border-radius: 10px;
`;

const Controls = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 15px;

  button {
    margin: 0 10px;
    padding: 10px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    background-color: ${({ theme }) => theme.colors.primary};
    color: white;
    transition: background-color 0.2s ease;

    &:hover {
      background-color: ${({ theme }) => theme.colors.secondary};
    }
  }

  label {
    display: flex;
    align-items: center;
    margin: 0 10px;
    color: ${({ theme }) => theme.colors.text};
    font-size: 14px;
  }

  input[type="range"] {
    width: 100px;
    margin-left: 5px;
  }
`;

const CloseButton = styled.button`
  margin-top: 15px;
  background-color: ${({ theme }) => theme.colors.error};
  border: none;
  color: white;
  padding: 8px 15px;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.2s ease;

  &:hover {
    background-color: #c0392b;
  }
`;

// AudioPlayer Component
function AudioPlayer({
  fileUrl,
  fileName,
  fileType,
  fileSize,
  duration = '', // Default value
  onClose,
}) {
  const waveformRef = useRef(null);
  const wavesurferRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [volume, setVolume] = useState(1);
  const [playbackRate, setPlaybackRate] = useState(1);
  const [loop, setLoop] = useState(false);
  const loopRef = useRef(loop); // Ref to keep track of loop state

  // Update loopRef whenever loop state changes
  useEffect(() => {
    loopRef.current = loop;
  }, [loop]);

  useEffect(() => {
    wavesurferRef.current = WaveSurfer.create({
      container: waveformRef.current,
      waveColor: '#D9DCFF',
      progressColor: '#4353FF',
      cursorColor: '#4353FF',
      responsive: true,
      height: 100,
      cursorWidth: 2,
      barWidth: 2,
    });

    wavesurferRef.current.load(fileUrl);
    wavesurferRef.current.setVolume(volume);
    wavesurferRef.current.setPlaybackRate(playbackRate);

    wavesurferRef.current.on('play', () => setIsPlaying(true));
    wavesurferRef.current.on('pause', () => setIsPlaying(false));
    wavesurferRef.current.on('finish', () => {
      setIsPlaying(false);
      if (loopRef.current) {
        wavesurferRef.current.play();
      }
    });

    return () => {
      wavesurferRef.current.destroy();
    };
  }, [fileUrl, volume, playbackRate]);

  const playPause = () => {
    wavesurferRef.current.playPause();
  };

  const stop = () => {
    wavesurferRef.current.stop();
  };

  const handleVolumeChange = (e) => {
    const newVolume = parseFloat(e.target.value);
    setVolume(newVolume);
    wavesurferRef.current.setVolume(newVolume);
  };

  const handlePlaybackRateChange = (e) => {
    const newRate = parseFloat(e.target.value);
    setPlaybackRate(newRate);
    wavesurferRef.current.setPlaybackRate(newRate);
  };

  const toggleLoop = () => {
    setLoop(!loop);
  };

  return (
    <AudioPlayerContainer>
      <h3>Now Playing: {fileName}</h3>
      {fileSize && <p>File Size: {(fileSize / (1024 * 1024)).toFixed(2)} MB</p>}
      {duration && <p>Duration: {duration}</p>}

      <div id="waveform" ref={waveformRef}></div>
      <Controls>
        <button onClick={playPause} aria-label={isPlaying ? 'Pause' : 'Play'}>
          <FontAwesomeIcon icon={isPlaying ? faPause : faPlay} />
        </button>
        <button onClick={stop} aria-label="Stop">
          <FontAwesomeIcon icon={faStop} />
        </button>
        <button onClick={toggleLoop} aria-label={loop ? 'Disable Loop' : 'Enable Loop'} style={{ backgroundColor: loop ? '#e74c3c' : '' }}>
          <FontAwesomeIcon icon={faRedo} />
        </button>
        <label>
          <FontAwesomeIcon icon={volume > 0 ? faVolumeUp : faVolumeMute} />
          <input
            type="range"
            min="0"
            max="1"
            step="0.01"
            value={volume}
            onChange={handleVolumeChange}
            aria-label="Volume Control"
          />
        </label>
        <label>
          Speed:
          <input
            type="range"
            min="0.5"
            max="2"
            step="0.1"
            value={playbackRate}
            onChange={handlePlaybackRateChange}
            aria-label="Playback Speed Control"
          />
        </label>
      </Controls>
      <CloseButton onClick={onClose} aria-label="Close Audio Player">Close</CloseButton>
    </AudioPlayerContainer>
  );
}

AudioPlayer.propTypes = {
  fileUrl: PropTypes.string.isRequired,
  fileName: PropTypes.string.isRequired,
  fileType: PropTypes.string.isRequired,
  fileSize: PropTypes.number.isRequired,
  duration: PropTypes.string,
  onClose: PropTypes.func.isRequired,
};

export default AudioPlayer;

```

## File: common/Tooltip.jsx

```jsx
// src/components/common/Tooltip.jsx
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';

// Transient Prop: $text
const TooltipWrapper = styled.div`
  position: relative;
  display: inline-block;

  &:hover::after {
    content: "${(props) => props.$text}";
    position: absolute;
    bottom: 125%; /* Position above the text */
    left: 50%;
    transform: translateX(-50%);
    background-color: ${({ theme }) => theme.colors.background};
    color: ${({ theme }) => theme.colors.text};
    padding: 5px 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    white-space: nowrap;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    z-index: 1001;
    opacity: 0.9;
    pointer-events: none; /* Prevent tooltip from interfering with hover */
  }

  &:hover::before {
    content: "";
    position: absolute;
    bottom: 115%;
    left: 50%;
    transform: translateX(-50%);
    border-width: 5px;
    border-style: solid;
    border-color: ${({ theme }) => theme.colors.background} transparent transparent transparent;
    opacity: 0.9;
    pointer-events: none;
  }
`;

function Tooltip({ $text, children }) {
  return <TooltipWrapper $text={$text}>{children}</TooltipWrapper>;
}

Tooltip.propTypes = {
  $text: PropTypes.string.isRequired, // Updated to $text
  children: PropTypes.node.isRequired,
};

export default Tooltip;

```

## File: common/ProgressBar.jsx

```jsx
// frontend/src/components/common/ProgressBar.jsx
import React from 'react';
import styled from 'styled-components';
import PropTypes from 'prop-types';

const ProgressBarContainer = styled.div`
  margin-top: 20px;
`;

const ProgressWrapper = styled.div`
  width: 100%;
  background-color: #e0e0e0;
  padding: 3px;
  border-radius: 6px;
  overflow: hidden;
`;

const ProgressBarStyled = styled.div`
  height: 22px;
  background: linear-gradient(90deg, ${({ theme }) => theme.colors.primary}, #00c6ff);
  border-radius: 3px;
  width: ${({ $progress }) => `${$progress}%`};
  transition: width 0.3s ease-in-out;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: 500;
`;

function ProgressBar({ progress }) {
  if (progress === 0) return null;

  return (
    <ProgressBarContainer>
      <ProgressWrapper>
        <ProgressBarStyled
          $progress={progress}
          role="progressbar"
          aria-valuenow={progress}
          aria-valuemin="0"
          aria-valuemax="100"
        >
          {progress}%
        </ProgressBarStyled>
      </ProgressWrapper>
    </ProgressBarContainer>
  );
}

ProgressBar.propTypes = {
  progress: PropTypes.number.isRequired,
};

export default ProgressBar;

```

## File: common/FileDashboard.jsx

```jsx
// src/components/common/FileDashboard.jsx
import React, { useState, useRef } from 'react';
import MediaPlayer from './MediaPlayer';
import styled from 'styled-components';
import PropTypes from 'prop-types';
import Tooltip from './Tooltip'; // Import Tooltip component

// Styled Components
const DashboardContainer = styled.div`
  margin-top: 30px;
`;

const FileGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 20px;

  @media (max-width: 1199px) {
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  }

  @media (max-width: 767px) {
    grid-template-columns: 1fr;
    gap: 15px;
  }
`;

const FileCard = styled.div`
  background-color: ${({ theme }) => theme.colors.neutral};
  padding: 20px;
  border-radius: 10px;
  box-sizing: border-box;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  text-align: center;
  transition: transform 0.2s ease, box-shadow 0.3s ease;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  justify-content: center;
  height: 150px; /* Fixed height for consistency */

  &:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
  }

  p {
    margin-bottom: 10px;
    color: ${({ theme }) => theme.colors.text};
    font-size: 16px;
    font-weight: 500;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  @media (max-width: 767px) {
    padding: 15px;
    height: auto;

    p {
      font-size: 14px;
    }
  }
`;

function FileDashboard({ uploadedFiles }) {
  const [currentIndex, setCurrentIndex] = useState(null);
  const triggerRef = useRef(null);

  const selectFile = (index, event) => {
    triggerRef.current = event.currentTarget;
    setCurrentIndex(index);
  };

  const closeMediaPlayer = () => {
    setCurrentIndex(null);
    if (triggerRef.current) {
      triggerRef.current.focus();
    }
  };

  const handleNextTrack = () => {
    setCurrentIndex((prevIndex) => {
      if (prevIndex === null) return 0;
      return (prevIndex + 1) % uploadedFiles.length;
    });
  };

  const handlePrevTrack = () => {
    setCurrentIndex((prevIndex) => {
      if (prevIndex === null) return uploadedFiles.length - 1;
      return (prevIndex - 1 + uploadedFiles.length) % uploadedFiles.length;
    });
  };

  return (
    <DashboardContainer>
      <h2>Uploaded Files</h2>
      <FileGrid>
        {uploadedFiles.length > 0 ? (
          uploadedFiles.map((file, index) => (
            <FileCard 
              key={index} 
              onClick={(e) => selectFile(index, e)} 
              tabIndex="0" 
              onKeyPress={(e) => {
                if (e.key === 'Enter') selectFile(index, e);
              }}
              aria-label={`Play ${file.filename}`}
            >
              <Tooltip $text={file.filename}> {/* Corrected to use $text */}
                <p>{file.filename}</p>
              </Tooltip>
              <p>{(file.size / (1024 * 1024)).toFixed(2)} MB</p>
              {/* Add more details if necessary */}
            </FileCard>
          ))
        ) : (
          <p>No files uploaded yet.</p>
        )}
      </FileGrid>
      {currentIndex !== null && (
        <MediaPlayer
          fileUrl={
            uploadedFiles[currentIndex].path.startsWith('/static/uploads') 
              ? `${window.location.origin}${uploadedFiles[currentIndex].path}` 
              : uploadedFiles[currentIndex].path
          }
          fileName={uploadedFiles[currentIndex].filename}
          fileType={uploadedFiles[currentIndex].type}
          fileSize={uploadedFiles[currentIndex].size}
          duration={uploadedFiles[currentIndex].duration}
          onClose={closeMediaPlayer}
          onNextTrack={handleNextTrack}
          onPrevTrack={handlePrevTrack}
        />
      )}
    </DashboardContainer>
  );
}

FileDashboard.propTypes = {
  uploadedFiles: PropTypes.arrayOf(
    PropTypes.shape({
      filename: PropTypes.string.isRequired,
      path: PropTypes.string.isRequired,
      size: PropTypes.number.isRequired,
      type: PropTypes.string.isRequired,
      duration: PropTypes.string,
    })
  ).isRequired,
};

export default FileDashboard;

```

## File: pages/Upload.jsx

```jsx
import React, { useState } from 'react';
import styled from 'styled-components';
import FileUploader from '../common/FileUploader';
import Notification from '../common/Notification';

const UploadContainer = styled.div`
  padding: 20px;
`;

function Upload() {
  const [notification, setNotification] = useState({ message: '', type: 'success' });
  const [uploadedFiles, setUploadedFiles] = useState([]);

  return (
    <UploadContainer>
      <h1>Upload Files</h1>
      {notification.message && (
        <Notification 
          message={notification.message} 
          type={notification.type} 
          onClose={() => setNotification({ message: '', type: 'success' })} 
        />
      )}
      <FileUploader 
        setUploadedFiles={setUploadedFiles} 
        setNotification={setNotification} 
      />
      {/* Optionally, display uploaded files after upload */}
      {uploadedFiles.length > 0 && (
        <div>
          <h2>Uploaded Files:</h2>
          <ul>
            {uploadedFiles.map((file, index) => (
              <li key={index}>{file.filename}</li>
            ))}
          </ul>
        </div>
      )}
    </UploadContainer>
  );
}

export default Upload;

```

## File: pages/Dashboard.jsx

```jsx
import React, { useEffect, useState } from 'react';
import styled from 'styled-components';
import FileDashboard from '../common/FileDashboard';
import Notification from '../common/Notification';

const DashboardContainer = styled.div`
  padding: 20px;
`;

function Dashboard() {
  const [uploadedFiles, setUploadedFiles] = useState([]);
  const [notification, setNotification] = useState({ message: '', type: 'success' });

  useEffect(() => {
    fetch('/api/file_history')
      .then((response) => response.json())
      .then((data) => {
        if (data.files) {
          setUploadedFiles(data.files);
        }
      })
      .catch((error) => {
        console.error('Error fetching file history:', error);
        setNotification({ message: 'Failed to fetch file history.', type: 'error' });
      });
  }, []);

  return (
    <DashboardContainer>
      <h1>Dashboard</h1>
      {notification.message && (
        <Notification 
          message={notification.message} 
          type={notification.type} 
          onClose={() => setNotification({ message: '', type: 'success' })} 
        />
      )}
      <FileDashboard uploadedFiles={uploadedFiles} />
    </DashboardContainer>
  );
}

export default Dashboard;

```

## File: pages/Settings.jsx

```jsx
import React, { useState } from 'react';
import styled from 'styled-components';
import Notification from '../common/Notification';
import Button from '../common/Button';

const SettingsContainer = styled.div`
  padding: 20px;
`;

const SettingsForm = styled.form`
  display: flex;
  flex-direction: column;
  gap: 15px;
`;

const Label = styled.label`
  font-size: ${({ theme }) => theme.fontSizes.body};
  color: ${({ theme }) => theme.colors.text};
`;

const Input = styled.input`
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: ${({ theme }) => theme.fontSizes.body};
  font-family: ${({ theme }) => theme.fonts.primary};

  &:focus {
    border-color: ${({ theme }) => theme.colors.primary};
    outline: none;
    box-shadow: 0 0 0 2px rgba(30, 144, 255, 0.2);
  }
`;

function Settings() {
  const [notification, setNotification] = useState({ message: '', type: 'success' });
  const [settings, setSettings] = useState({
    username: '',
    email: '',
  });

  const handleChange = (e) => {
    setSettings({
      ...settings,
      [e.target.name]: e.target.value,
    });
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    // Implement settings update logic here
    setNotification({ message: 'Settings updated successfully!', type: 'success' });
  };

  return (
    <SettingsContainer>
      <h1>Settings</h1>
      {notification.message && (
        <Notification 
          message={notification.message} 
          type={notification.type} 
          onClose={() => setNotification({ message: '', type: 'success' })} 
        />
      )}
      <SettingsForm onSubmit={handleSubmit}>
        <div>
          <Label htmlFor="username">Username</Label>
          <Input 
            type="text" 
            id="username" 
            name="username" 
            value={settings.username} 
            onChange={handleChange} 
            required 
          />
        </div>
        <div>
          <Label htmlFor="email">Email</Label>
          <Input 
            type="email" 
            id="email" 
            name="email" 
            value={settings.email} 
            onChange={handleChange} 
            required 
          />
        </div>
        <Button variant="primary" type="submit">
          Save Settings
        </Button>
      </SettingsForm>
    </SettingsContainer>
  );
}

export default Settings;

```

